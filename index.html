<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Code Rivals - C++ Challenge</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<!-- Removed Socket.IO script as no backend is being used for this local-only version -->
<style>
    /* General Body and Font Styles */
    body {
        margin: 0;
        padding: 0;
        background: radial-gradient(circle at center, #001f3f, #000);
        font-family: 'Inter', sans-serif; /* General text font */
        color: #00ccff;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        width: 100vw;
        overflow-x: hidden; /* Prevent horizontal scroll */
        overflow-y: auto; /* Allow vertical scroll for content */
    }

    h1, h2, h3 {
        font-family: 'Orbitron', sans-serif; /* Keep Orbitron for titles */
        text-shadow: 0 0 10px #00ccff;
        color: #00ccff;
    }

    h1 {
        margin: 20px 0 10px;
        font-size: 32px;
    }

    /* Shared Primary Button Style */
    .primary-btn {
        padding: 8px 16px;
        background-color: #001f3f;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ccff;
        border-radius: 8px;
        transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
    }

    .primary-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 15px #00ff00;
        background-color: #003f6f; /* Slightly darker on hover */
    }

    .primary-btn:disabled {
        cursor: not-allowed;
        opacity: 0.5;
        background-color: #555;
        border-color: #888;
        box-shadow: none;
    }

    /* Logout Button */
    #logoutBtn {
        position: absolute;
        top: 10px;
        right: 10px; /* Keep this as the rightmost */
        background-color: #a00000; /* Red color for logout */
        border-color: #ff0000;
        color: #fff;
        box-shadow: 0 0 10px #ff0000;
        z-index: 10;
        display: none; /* Hidden by default */
    }
    #logoutBtn:hover {
        background-color: #cc0000;
        box-shadow: 0 0 15px #ff6666;
    }

    #welcomeMessage {
        color: #fff;
        font-size: 18px;
        margin-top: 10px;
        display: none;
        text-align: center;
        margin-bottom: 20px;
    }

    /* Authentication Container */
    #authContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background-color: rgba(0,0,50,0.9);
        border: 2px solid #00ccff;
        border-radius: 20px;
        padding: 30px;
        width: 90%;
        max-width: 400px;
        text-align: center;
        box-shadow: 0 0 25px #00ccff;
        margin-top: 50px;
    }

    #authContainer h2 {
        margin-top: 0;
        margin-bottom: 25px;
    }

    #authContainer input[type="text"],
    #authContainer input[type="password"] {
        width: calc(100% - 20px);
        padding: 12px;
        margin-bottom: 15px;
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        font-size: 16px;
        box-sizing: border-box;
    }

    #authContainer button {
        width: 100%;
        padding: 12px;
        font-size: 18px;
        margin-bottom: 10px;
    }

    #authSwitch {
        color: #00ccff;
        text-decoration: underline;
        cursor: pointer;
        font-size: 14px;
        margin-top: 15px;
        transition: color 0.2s;
    }
    #authSwitch:hover {
        color: #00ff00;
    }

    /* Game Mode Selection */
    #gameModeSelection, #rankedGameModeSelection { /* Added #rankedGameModeSelection */
        display: none; /* Hidden by default, shown after selecting a mode from main dashboard */
        flex-direction: column;
        align-items: center;
        background-color: rgba(0,0,50,0.9); /* Keep background for the container */
        border: 2px solid #00ccff;
        border-radius: 20px;
        padding: 20px;
        width: 90%;
        max-width: 600px;
        text-align: center;
        box-shadow: 0 0 20px #00ccff;
        margin-top: 50px;
        gap: 20px;
    }

    .game-mode-box {
        width: 100%;
        background-color: rgba(0, 0, 50, 0.8); /* Slightly transparent background for the box itself */
        border: 2px solid #00ccff;
        border-radius: 15px; /* Rounded corners for the box */
        padding: 25px; /* Increased padding for bigger buttons */
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
        box-shadow: 0 0 15px #00ccff; /* Initial glow */
        text-align: center; /* Center text within the box */
    }

    .game-mode-box:hover {
        transform: translateY(-5px);
        box-shadow: 0 0 30px #00ff00; /* More intense glow on hover */
        background-color: rgba(0, 31, 63, 0.9); /* Slightly darker on hover */
    }

    .game-mode-box h3 {
        margin-top: 0;
        margin-bottom: 10px; /* Space between title and description */
        font-size: 24px; /* Larger title */
        text-shadow: 0 0 10px #00ccff;
    }

    .game-mode-box p {
        font-size: 16px; /* Larger description */
        color: #e0f2f7; /* Lighter color for readability */
        margin: 0;
    }

    /* Main Lobby Dashboard - Adjusted for full screen */
    #mainLobbyDashboard {
        /* Removed position: relative; as profile icon is now global */
        display: none; /* Hidden by default, shown after login */
        flex-direction: row; /* Default to row for wider screens */
        gap: 20px;
        width: 98%; /* Increased width to take more space */
        /* Removed max-width to allow it to expand more */
        justify-content: center;
        align-items: stretch;
        flex-grow: 1;
        min-height: 80vh;
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
        margin-top: 20px;
        margin-bottom: 20px; /* Add some bottom margin */
    }

    .main-panel {
        background-color: rgba(0,0,50,0.9);
        border: 2px solid #00ccff;
        border-radius: 20px;
        box-shadow: 0 0 20px #00ccff;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        box-sizing: border-box;
        /* Ensure panels can grow and shrink */
        min-height: 300px; /* Ensure a minimum height for panels */
    }

    .left-panel-modes {
        flex: 1; /* Allow it to grow, but with a smaller base */
        min-width: 200px; /* Minimum width to prevent squishing */
        max-width: 250px; /* Keep it relatively narrow */
        gap: 15px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }

    /* Make buttons inside left-panel-modes bigger */
    .left-panel-modes .primary-btn {
        padding: 15px 25px; /* Increased padding */
        font-size: 20px; /* Increased font size */
    }

    .center-panel-leaderboard {
        flex: 3; /* Increased flex-grow to take significantly more space */
        min-width: 450px; /* Increased minimum width for leaderboard */
    }

    .right-panel-updates {
        flex: 1.5; /* Takes more space than left, less than center */
        min-width: 300px; /* Minimum width for updates */
        max-width: 350px; /* Keep it relatively narrow */
        gap: 20px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }

    .right-panel-updates ul {
        list-style: none;
        padding: 0;
        margin: 0;
        text-align: left;
        font-size: 14px;
        color: #e0f2f7;
        flex-grow: 1; /* Allow the list to take available space */
        overflow-y: auto; /* Add scroll if content overflows */
    }

    .right-panel-updates ul li {
        margin-bottom: 5px;
    }

    /* Top Right Icons (Logout, Profile, Inventory, Shop, Code Input) */
    /* Position them all relative to the right edge, ordered from right to left */
    #logoutBtn {
        right: 10px; /* Rightmost */
    }
    #profileIcon {
        right: 60px; /* 10 (logout) + 40 (logout width) + 10 (gap) */
    }
    #inventoryIcon {
        right: 110px; /* 60 (profile) + 40 (profile width) + 10 (gap) */
    }
    #shopIcon {
        right: 160px; /* 110 (inventory) + 40 (inventory width) + 10 (gap) */
    }
    #codeInputIcon {
        right: 210px; /* 160 (shop) + 40 (shop width) + 10 (gap) */
    }

    .top-right-icon {
        position: absolute;
        top: 10px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: rgba(0, 0, 50, 0.8);
        border: 2px solid #00ccff;
        box-shadow: 0 0 10px #00ccff;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        z-index: 10;
        display: none; /* Hidden by default, managed by JS */
    }

    .top-right-icon:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 15px #00ff00; /* Green glow on hover */
    }

    .top-right-icon svg {
        width: 24px;
        height: 24px;
        fill: #00ccff;
    }


    /* Lobby List & Single Lobby View */
    .lobby-list-container {
        display: none;
        flex-direction: column;
        align-items: center;
        background-color: rgba(0,0,50,0.9);
        border: 2px solid #00ccff;
        border-radius: 20px;
        padding: 20px;
        width: 90%;
        max-width: 800px;
        text-align: center;
        box-shadow: 0 0 20px #00ccff;
        margin-top: 50px;
        overflow-y: auto;
        max-height: 80vh;
    }

    .lobby-header {
        display: flex;
        justify-content: space-between; /* Pushes items to the ends */
        align-items: center;
        width: 100%;
        margin-bottom: 20px;
        /* Removed flex-wrap: wrap; for horizontal layout on larger screens */
        gap: 10px; /* Spacing between items */
    }

    .lobby-header button {
        /* No specific margins needed here, flexbox gap handles spacing */
        position: static; /* Ensure no absolute positioning interferes */
        margin: 0; /* Reset any default margins */
        flex-shrink: 0; /* Prevent buttons from shrinking too much */
    }
    .lobby-header h2 {
        flex-grow: 1; /* Allow the title to take up available space */
        text-align: center; /* Center the text within its flex item */
        margin: 0; /* Reset any default margins */
        white-space: nowrap; /* Prevent title from wrapping */
        overflow: hidden; /* Hide overflow if title is too long */
        text-overflow: ellipsis; /* Add ellipsis if title is too long */
    }

    .lobby-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        width: 100%;
        padding: 10px;
    }

    .lobby-card {
        background-color: #001f3f;
        border: 2px solid #00ccff;
        border-radius: 15px;
        padding: 20px;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        text-align: left;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        min-height: 120px;
    }

    .lobby-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 0 25px #00ccff;
    }

    .lobby-card h3 {
        margin: 0 0 10px 0;
        text-shadow: 0 0 5px #00ccff;
        font-size: 1.2em;
    }

    .lobby-card p {
        margin: 5px 0;
        font-size: 0.9em;
    }

    .lobby-card .join-btn {
        padding: 8px 15px;
        background-color: #004d40;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ccff;
        border-radius: 8px;
        transition: background-color 0.2s, box-shadow 0.2s;
        margin-top: 10px;
        align-self: flex-end;
    }

    .lobby-card .join-btn:hover {
        background-color: #00645a;
        box-shadow: 0 0 15px #00ff00;
    }

    .lobby-card.full {
        opacity: 0.7;
        cursor: not-allowed;
        background-color: #333;
    }

    .lobby-card.full .join-btn {
        background-color: #666;
        border-color: #999;
        cursor: not-allowed;
        box-shadow: none;
    }

    #startGameButton {
        padding: 12px 25px;
        background-color: #008000;
        border: 2px solid #00ff00;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ff00;
        border-radius: 8px;
        transition: background-color 0.2s, box-shadow 0.2s;
        margin-top: 20px;
    }

    #startGameButton:hover:not(:disabled) {
        background-color: #00b300;
        box-shadow: 0 0 15px #00ff00;
    }

    #startGameButton:disabled {
        cursor: not-allowed;
        opacity: 0.5;
        background-color: #555;
        border-color: #888;
        box-shadow: none;
    }

    #currentLobbyInfo {
        margin-top: 10px;
        font-size: 1.1em;
        color: #fff;
        text-shadow: 0 0 5px #00ccff;
        display: block; /* Always display in single lobby view */
    }

    .player-status {
        font-size: 0.9em;
        font-weight: bold;
        padding: 4px 8px;
        border-radius: 10px;
        margin-left: 10px;
    }

    .player-status.ready {
        background-color: #00ff00;
        color: #003300;
    }

    .player-status.not-ready {
        background-color: #ff0000;
        color: #330000;
    }

    /* Main Content Wrapper (for game UI and solo challenge) */
    .main-content-wrapper {
        display: none; /* Managed by JS */
        flex-direction: row; /* Default to row for wider screens */
        gap: 20px;
        width: 98%; /* Increased width */
        max-width: 1600px; /* Increased max-width for game content */
        justify-content: center;
        align-items: stretch;
        flex-grow: 1;
        min-height: 80vh;
        flex-wrap: wrap;
        margin-bottom: 20px; /* Add some bottom margin */
    }

    /* Game UI (Common for 4v4 and 1v1) */
    #gameUI {
        display: none; /* Managed by JS */
        flex-direction: column;
        align-items: center;
        margin-top: 10px;
        flex-grow: 1;
        width: 100%; /* Ensure it takes full width when active */
    }

    /* New wrapper for 4v4 game area and chat */
    .multiplayer-game-area {
        display: flex;
        flex-direction: row; /* Arrange game and chat side-by-side */
        gap: 20px;
        width: 100%; /* Take full width of its parent */
        justify-content: space-between; /* Distribute space to push chat right */
        align-items: flex-start; /* Align items to the top */
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .game-container {
        position: relative;
        flex-grow: 1; /* Allow it to grow */
        min-width: 450px;
        max-width: 900px;
        height: 650px; /* Fixed height */
        border: 2px solid #00ccff;
        border-radius: 20px;
        box-shadow: 0 0 30px #00ccff inset;
        background-color: rgba(0, 0, 50, 0.9);
        overflow: hidden;
        margin: 0 auto; /* Center it horizontally */
    }

    .player-circle {
        position: absolute;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .player {
        position: absolute;
        width: 100px;
        text-align: center;
        transform: translate(-50%, -50%);
    }

    .player .name {
        font-weight: bold;
        font-size: 16px;
    }

    .player .name.active {
        color: yellow;
        text-shadow: 0 0 10px yellow;
    }

    .player .name.correct {
        color: lime;
        text-shadow: 0 0 10px lime;
    }

    .player .name.wrong {
        color: red;
        text-shadow: 0 0 10px red;
    }

    .player .lives {
        font-size: 12px;
    }

    #timer {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
        text-shadow: 0 0 10px #00ccff;
    }

    /* Common question box style */
    .question-box {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0,0,50,0.7);
        padding: 20px;
        border: 2px solid #00ccff;
        border-radius: 10px;
        box-shadow: 0 0 10px #00ccff;
        width: 90%;
        max-width: 700px;
        text-align: center;
        box-sizing: border-box;
    }

    .question-box input[type="text"] {
        padding: 10px;
        font-size: 16px;
        width: calc(70% - 15px);
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        margin-right: 10px;
        box-sizing: border-box;
    }

    .question-box button {
        padding: 10px 20px;
        background-color: #001f3f;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ccff;
        border-radius: 5px;
        transition: background-color 0.2s, box-shadow 0.2s;
    }
    .question-box button:hover {
        background-color: #003f6f;
        box-shadow: 0 0 15px #00ff00;
    }

    .replay-button {
        margin-top: 20px;
        display: none;
    }

    /* Leaderboard Styles */
    #leaderboard, #globalLeaderboard {
        margin-top: 20px;
        width: 95%;
        max-width: 900px;
        background-color: rgba(0,0,0,0.85);
        border: 3px solid #00ccff;
        border-radius: 20px;
        padding: 10px;
        color: #00ccff;
        font-size: 14px;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 0 15px #00ccff;
        height: auto;
        margin-bottom: 20px;
    }

    #leaderboard table, #globalLeaderboard table {
        width: 100%;
        border-collapse: collapse;
        font-family: 'Orbitron', sans-serif;
    }

    #leaderboard th, #leaderboard td, #globalLeaderboard th, #globalLeaderboard td {
        padding: 12px 10px;
        border: 1px solid #00ccff;
    }

    #leaderboard thead, #globalLeaderboard thead {
        background-color: #000;
        color: #00ccff;
        font-size: 18px;
        text-shadow: 0 0 5px #00ccff;
    }

    #leaderboard tbody tr:nth-child(odd), #globalLeaderboard tbody tr:nth-child(odd) {
        background-color: rgba(0, 0, 50, 0.6);
    }

    #leaderboard tbody tr:nth-child(even), #globalLeaderboard tbody tr:nth-child(even) {
        background-color: rgba(0, 0, 100, 0.4);
    }

    #leaderboard tbody td, #globalLeaderboard tbody td {
        font-size: 16px;
    }

    /* Layout for 4v4 Q&A */
    #four-v-four-qna-layout {
        display: none; /* Managed by JS */
        flex-direction: column;
        align-items: center;
        gap: 20px;
        width: 100%;
        flex-grow: 1;
    }

    /* Layout for 1v1 Fill-in-the-Blanks */
    #one-v-one-fill-in-blanks-layout {
        display: none; /* Managed by JS */
        flex-direction: column;
        width: 100%;
        flex-grow: 1;
        gap: 20px;
    }

    .side-by-side-game-area {
        display: flex;
        justify-content: space-between; /* Distribute space to push chat right */
        gap: 20px;
        width: 100%;
        flex-grow: 1;
        align-items: flex-start; /* Align items to the top */
        flex-wrap: wrap; /* Ensure responsiveness */
    }

    /* New wrapper for 1v1 player panels to center them as a group */
    .player-panels-wrapper {
        display: flex;
        flex-direction: row;
        gap: 20px;
        flex-grow: 1; /* Allow it to take available space */
        justify-content: center; /* Center the two player panels within this wrapper */
        align-items: stretch; /* Make panels same height */
        min-width: 600px; /* Ensure enough space for two panels */
        max-width: 900px; /* Match game-container max-width */
        margin: 0 auto; /* Center the wrapper itself */
    }

    .player-panel {
        background-color: rgba(0, 0, 50, 0.9);
        border: 2px solid #00ccff;
        border-radius: 15px;
        box-shadow: 0 0 20px #00ccff;
        padding: 20px;
        flex: 1;
        min-width: 280px;
        text-align: center;
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }

    .player-panel.active-player-turn {
        border-color: yellow;
        box-shadow: 0 0 25px yellow;
    }

    .player-panel h3 {
        text-shadow: 0 0 8px #00ccff;
        margin-top: 0;
    }
    .player-panel p {
        font-size: 14px;
        margin-bottom: 5px;
    }

    /* 1v1 specific question box, positioned inside player panel */
    .question-box-1v1 {
        position: relative;
        background-color: rgba(0,0,50,0.9);
        padding: 15px;
        border: 1px solid #00ccff;
        border-radius: 8px;
        box-shadow: 0 0 8px #00ccff;
        width: calc(100% - 20px);
        margin-top: auto;
        margin-left: auto;
        margin-right: auto;
        box-sizing: border-box;
    }
    .question-box-1v1 input[type="text"] {
        padding: 10px;
        font-size: 16px;
        width: calc(100% - 80px);
        margin-right: 10px;
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        box-sizing: border-box;
    }
    .question-box-1v1 button {
        padding: 10px 20px;
        background-color: #001f3f;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ccff;
        border-radius: 5px;
        transition: background-color 0.2s, box-shadow 0.2s;
    }
    .question-box-1v1 button:hover {
        background-color: #003f6f;
        box-shadow: 0 0 15px #00ff00;
    }


    /* Chat box layout (common styles) */
    .chat-box-layout {
        background-color: rgba(0, 0, 50, 0.9);
        border: 2px solid #00ccff;
        border-radius: 10px;
        box-shadow: 0 0 20px #00ccff;
        padding: 15px;
        display: flex;
        flex-direction: column;
        min-height: 300px; /* Keep min-height for small screens */
        height: 650px; /* Make it same height as game-container */
        flex-shrink: 0; /* Prevent shrinking */
        flex-basis: 250px; /* Give it a preferred width */
        max-width: 300px; /* Optional: limit max width */
    }

    /* Adjustments for 4v4 chat box within the new layout */
    #chatBox4v4 {
        /* No specific order needed, it's already last in HTML */
        /* flex-basis and max-width from .chat-box-layout apply */
    }

    .chat-messages {
        flex-grow: 1;
        overflow-y: auto;
        border: 1px solid #00ccff;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        color: #00ccff;
        font-size: 14px;
        word-wrap: break-word;
        min-height: 150px;
    }

    .chat-box-layout input[type="text"] {
        padding: 8px;
        font-size: 14px;
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        width: calc(100% - 16px);
        margin-bottom: 5px;
    }

    .chat-box-layout button {
        padding: 8px 15px;
        background-color: #001f3f;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #00ccff;
        border-radius: 5px;
        width: 100%;
        transition: background-color 0.2s, box-shadow 0.2s;
    }
    .chat-box-layout button:hover {
        background-color: #003f6f;
        box-shadow: 0 0 15px #00ff00;
    }

    /* Adjustments for 1v1 chat box within the side-by-side layout */
    .middle-chat-divider {
        /* No specific order needed, it's already last in HTML */
        /* flex-basis and max-width from .chat-box-layout apply */
    }

    .ranking-area {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin-top: 20px;
    }
    .ranking-area #leaderboard, .ranking-area #globalLeaderboard {
        width: 90%;
        max-width: 900px;
    }

    /* Solo Challenge UI */
    #soloChallengeUI {
        display: none; /* Managed by JS */
        flex-direction: column;
        align-items: center;
        background-color: rgba(0,0,50,0.9);
        border: 2px solid #00ccff;
        border-radius: 20px;
        box-shadow: 0 0 30px #00ccff inset;
        padding: 20px;
        width: 90%;
        max-width: 900px; /* Adjusted max-width for solo challenge */
        min-height: 650px;
        margin-top: 10px;
        position: relative;
        flex-grow: 1;
        box-sizing: border-box;
    }

    #soloChallengeUI h2 {
        margin-top: 0;
    }

    #soloProblemDescription {
        background-color: rgba(0,0,0,0.7);
        border: 1px solid #00ccff;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        width: calc(100% - 30px);
        min-height: 80px;
        overflow-y: auto;
        font-size: 16px;
        box-sizing: border-box;
    }

    #soloCodeEditor {
        width: calc(100% - 20px);
        height: 200px;
        background-color: #000;
        color: #00ff00; /* Green text for code editor */
        border: 1px solid #00ccff;
        border-radius: 5px;
        padding: 10px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        resize: vertical;
        margin-bottom: 15px;
        box-sizing: border-box;
    }

    #soloChallengeButtons {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
    }

    #soloChallengeButtons button {
        padding: 12px 25px;
    }

    #soloLoadingIndicator {
        display: none;
        text-align: center;
        margin-top: 10px;
        font-size: 18px;
        color: yellow;
    }

    #soloResult {
        background-color: rgba(0,0,0,0.7);
        border: 1px solid #00ccff;
        border-radius: 8px;
        padding: 15px;
        width: calc(100% - 30px);
        min-height: 80px;
        overflow-y: auto;
        font-size: 14px;
        white-space: pre-wrap;
        box-sizing: border-box;
    }

    /* Custom Modal for Alerts */
    .custom-modal {
        display: none; /* Corrected: Initially hidden by default */
        position: fixed;
        z-index: 20;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.8);
        justify-content: center;
        align-items: center;
    }

    .custom-modal-content {
        background-color: rgba(0,0,50,0.95);
        margin: auto;
        padding: 30px;
        border: 3px solid #00ccff;
        border-radius: 15px;
        width: 90%;
        max-width: 400px;
        text-align: center;
        box-shadow: 0 0 25px #00ccff;
        transform: scale(0.95);
        animation: modalFadeIn 0.3s forwards;
        color: #fff;
    }

    .custom-modal-content h3 {
        margin-top: 0;
        margin-bottom: 20px;
        font-size: 24px;
    }

    .custom-modal-content p {
        font-size: 16px;
        margin-bottom: 25px;
        line-height: 1.5;
    }

    /* Apply primary-btn style to modal buttons */
    .custom-modal-content button {
        padding: 12px 25px; /* Adjust padding for modal buttons */
        font-size: 18px; /* Adjust font size for modal buttons */
        width: auto; /* Allow buttons to size content */
        min-width: 100px; /* Ensure a minimum width */
        margin: 0 5px; /* Spacing between buttons */
    }

    @keyframes modalFadeIn {
        from { opacity: 0; transform: scale(0.8); }
        to { opacity: 1; transform: scale(1); }
    }

    /* Create Lobby Modal */
    #createLobbyModal {
        display: none; /* Hidden by default */
        position: fixed;
        z-index: 20;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.8);
        justify-content: center;
        align-items: center;
    }

    #createLobbyModal .custom-modal-content {
        padding: 25px;
        max-width: 450px;
    }

    #createLobbyModal .custom-modal-content h3 {
        margin-bottom: 15px;
        font-size: 22px;
    }

    #createLobbyModal .custom-modal-content label {
        display: block;
        text-align: left;
        margin-bottom: 8px;
        color: #00ccff;
        font-size: 15px;
    }

    #createLobbyModal .custom-modal-content input[type="text"],
    #createLobbyModal .custom-modal-content select {
        width: calc(100% - 20px);
        padding: 10px;
        margin-bottom: 20px;
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        font-size: 16px;
        box-sizing: border-box;
    }

    #createLobbyModal .custom-modal-content select {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url('data:image/svg+xml;utf8,<svg fill="%2300ccff" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 16px;
    }

    .modal-buttons {
        display: flex;
        justify-content: center;
        margin-top: 10px;
    }
    .modal-buttons button {
        width: auto;
        min-width: 120px;
        margin: 0 10px;
    }

    /* Inventory and Shop Styles */
    .game-section-container { /* New class for common styling of inventory, shop, profile */
        display: none;
        flex-direction: column;
        align-items: center;
        background-color: rgba(0,0,50,0.9);
        border: 2px solid #00ccff;
        border-radius: 20px;
        padding: 20px;
        width: 90%;
        max-width: 1000px;
        text-align: center;
        box-shadow: 0 0 20px #00ccff;
        margin-top: 50px;
        overflow-y: auto;
        max-height: 80vh;
    }

    .game-section-container h2 {
        margin-top: 0;
        margin-bottom: 20px;
    }

    #shopContainer {
        border-color: #007bff; /* Blue theme for shop */
        box-shadow: 0 0 20px #007bff;
    }

    #shopContainer .primary-btn {
        border-color: #007bff;
        box-shadow: 0 0 10px #007bff;
    }

    #shopContainer .primary-btn:hover {
        box-shadow: 0 0 15px #00aaff;
        background-color: #0056b3;
    }

    .item-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 20px;
        width: 100%;
        padding: 10px;
    }

    .item-card {
        background-color: #001f3f;
        border: 2px solid #00ccff;
        border-radius: 15px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 0 10px #00ccff;
        transition: transform 0.2s, box-shadow 0.2s;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        min-height: 220px; /* Ensure consistent card height */
    }

    .item-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 0 25px #00ff00; /* Green glow for hover */
    }

    .item-card img {
        max-width: 100%;
        height: 100px; /* Fixed height for image area */
        object-fit: contain; /* Ensure image fits without distortion */
        border-radius: 8px;
        margin-bottom: 10px;
        background-color: rgba(0,0,0,0.3); /* Slight background for image area */
    }

    .item-card h3 {
        margin: 0 0 5px 0;
        font-size: 1.1em;
        text-shadow: 0 0 5px #00ccff;
    }

    .item-card p {
        font-size: 0.9em;
        color: #e0f2f7;
        margin-bottom: 10px;
        flex-grow: 1; /* Allow description to take space */
    }

    .item-card .price {
        font-weight: bold;
        color: #00ff00; /* Green for price */
        margin-bottom: 10px;
    }

    .item-card .buy-btn {
        padding: 8px 15px;
        background-color: #0056b3; /* Blue for buy button */
        border: 2px solid #007bff;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #007bff;
        border-radius: 8px;
        transition: background-color 0.2s, box-shadow 0.2s;
        width: 100%;
    }

    .item-card .buy-btn:hover {
        background-color: #004085;
        box-shadow: 0 0 15px #00aaff;
    }

    .item-card.owned .buy-btn {
        background-color: #333;
        border-color: #666;
        cursor: not-allowed;
        box-shadow: none;
        color: #aaa;
    }

    #currentTokensDisplay {
        font-size: 1.2em;
        font-weight: bold;
        color: #00ff00; /* Green for tokens */
        margin-bottom: 20px;
        text-shadow: 0 0 8px #00ff00;
    }

    /* Profile Page Styles (Blue Lock Rivals / Osu inspired) */
    #profilePage {
        display: none; /* Managed by JS */
        flex-direction: column;
        align-items: center;
        background: linear-gradient(135deg, #001a33, #000d1a); /* Dark gradient background */
        border: 3px solid #00ccff; /* Neon blue border */
        border-radius: 25px;
        box-shadow: 0 0 35px #00ccff, 0 0 15px rgba(0,204,255,0.5) inset; /* Double glow effect */
        padding: 30px;
        width: 90%;
        max-width: 900px;
        margin-top: 50px;
        margin-bottom: 20px;
        color: #e0f2f7; /* Light text color */
        font-family: 'Inter', sans-serif;
        overflow-y: auto;
        max-height: 85vh;
    }

    #profileHeader {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        margin-bottom: 30px;
        width: 100%;
    }

    #profileAvatar {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background-color: #002a4d; /* Darker blue for avatar background */
        border: 4px solid #00ff00; /* Green highlight for active player */
        box-shadow: 0 0 20px #00ff00;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 60px;
        color: #00ccff;
        font-weight: bold;
        text-shadow: 0 0 10px #00ccff;
        overflow: hidden; /* For potential custom avatars */
    }

    #profileAvatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    #profileUsername {
        font-family: 'Orbitron', sans-serif;
        font-size: 36px;
        color: #00ccff;
        text-shadow: 0 0 15px #00ccff;
        margin: 0;
    }

    #profileStatsGrid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 20px;
        width: 100%;
        margin-bottom: 30px;
        text-align: center;
    }

    .stat-item {
        background-color: rgba(0, 0, 50, 0.7);
        border: 2px solid #00ccff;
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 0 10px #00ccff;
    }

    .stat-item h4 {
        margin: 0 0 8px 0;
        font-size: 1.1em;
        color: #00ff00; /* Green for stat titles */
        text-shadow: 0 0 5px #00ff00;
    }

    .stat-item p {
        margin: 0;
        font-size: 1.5em;
        font-weight: bold;
        color: #e0f2f7;
    }

    #profileSections {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 25px;
    }

    .profile-section-box {
        background-color: rgba(0, 0, 50, 0.7);
        border: 2px solid #00ccff;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 0 15px #00ccff;
        text-align: left;
    }

    .profile-section-box h3 {
        font-family: 'Orbitron', sans-serif;
        color: #00ccff;
        text-shadow: 0 0 8px #00ccff;
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.5em;
    }

    #profileAchievements ul, #profileInventoryList ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 10px;
    }

    #profileAchievements li, #profileInventoryList li {
        background-color: rgba(0, 0, 0, 0.5);
        border: 1px solid #00ccff;
        border-radius: 8px;
        padding: 8px;
        font-size: 0.9em;
        text-align: center;
        color: #e0f2f7;
    }

    #profileTitles {
        text-align: center;
    }
    #profileTitles p {
        font-size: 1.2em;
        color: #00ff00;
        font-weight: bold;
        margin-top: 10px;
    }

    /* Shop Categories */
    .shop-category-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
    }

    .shop-category-buttons button {
        padding: 10px 20px;
        background-color: #001f3f;
        border: 2px solid #00ccff;
        color: #00ccff;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 8px #00ccff;
        border-radius: 8px;
        transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
    }

    .shop-category-buttons button.active,
    .shop-category-buttons button:hover {
        background-color: #003f6f;
        box-shadow: 0 0 15px #00ff00;
        transform: translateY(-2px);
    }

    /* Card Display in Game */
    .player-cards-container {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
        flex-wrap: wrap;
        width: 100%;
        max-width: 900px;
        min-height: 120px; /* Give it some height */
        padding: 10px;
        background-color: rgba(0,0,0,0.5);
        border: 1px solid #00ccff;
        border-radius: 10px;
        box-sizing: border-box;
    }

    .player-card-item {
        width: 100px;
        height: 100px;
        background-color: #003f6f;
        border: 2px solid #00ccff;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 0.8em;
        font-weight: bold;
        color: #e0f2f7;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s, opacity 0.5s;
        box-shadow: 0 0 8px #00ccff;
        position: relative; /* For burning effect */
        overflow: hidden;
    }

    .player-card-item:hover {
        transform: scale(1.05);
        box-shadow: 0 0 15px #00ff00;
    }

    .player-card-item.used {
        opacity: 0; /* Hide when used */
        pointer-events: none; /* Disable interaction */
        animation: cardBurn 1s forwards; /* Burning effect */
    }

    @keyframes cardBurn {
        0% { opacity: 1; transform: scale(1); filter: brightness(1); }
        50% { opacity: 0.5; transform: scale(1.1); filter: brightness(2); }
        100% { opacity: 0; transform: scale(0.5); filter: brightness(0.5); }
    }

    .card-icon {
        width: 40px;
        height: 40px;
        margin-bottom: 5px;
        fill: #00ccff;
    }

    /* Shield display */
    .shield-icon {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 20px;
        height: 20px;
        fill: gold;
        text-shadow: 0 0 5px orange;
        z-index: 5;
    }

    /* Meta Vision Overlay */
    #metaVisionOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.8);
        z-index: 30;
        justify-content: center;
        align-items: center;
    }

    #metaVisionContent {
        background-color: rgba(0,0,50,0.95);
        border: 3px solid #00ccff;
        border-radius: 15px;
        padding: 25px;
        max-width: 600px;
        width: 90%;
        text-align: center;
        box-shadow: 0 0 25px #00ccff;
        color: #e0f2f7;
    }

    #metaVisionContent h3 {
        margin-top: 0;
        color: #00ccff;
    }

    #metaVisionPlayerDecks {
        display: flex;
        flex-direction: column;
        gap: 15px;
        max-height: 400px;
        overflow-y: auto;
        padding: 10px;
        border: 1px solid rgba(0,204,255,0.3);
        border-radius: 8px;
        background-color: rgba(0,0,0,0.3);
    }

    .meta-vision-player-deck {
        border: 1px dashed #00ccff;
        padding: 10px;
        border-radius: 8px;
        text-align: left;
    }

    .meta-vision-player-deck h4 {
        margin-top: 0;
        margin-bottom: 10px;
        color: #00ff00;
    }

    .meta-vision-player-deck .card-list {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
    }

    .meta-vision-player-deck .card-list span {
        background-color: #001f3f;
        border: 1px solid #00ccff;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 0.9em;
    }

    /* Responsive adjustments */
    @media (max-width: 992px) {
        #mainLobbyDashboard {
            flex-direction: column;
            align-items: center;
        }
        .left-panel-modes, .center-panel-leaderboard, .right-panel-updates {
            width: 95%;
            max-width: 600px; /* Adjust max-width for panels on smaller screens */
            flex: none; /* Disable flex-grow on smaller screens when stacked */
        }
        #gameModeSelection, #rankedGameModeSelection, .game-section-container, #profilePage { /* Updated to new common class */
            width: 95%;
            max-width: 600px;
        }
        .game-container, #soloChallengeUI {
            width: 95%;
            max-width: 650px;
        }
        .side-by-side-game-area {
            flex-direction: column;
        }
        .multiplayer-game-area {
            flex-direction: column; /* Stack vertically on smaller screens */
            align-items: center; /* Center items when stacked */
        }
        #chatBox4v4, .game-container, .player-panels-wrapper, .middle-chat-divider, .player-panel {
            width: 95%; /* Take full width on smaller screens */
            max-width: 650px; /* Limit max width */
            flex: none; /* Disable flex-grow/shrink when stacked */
            height: auto; /* Allow height to adjust when stacked */
            margin: 0 auto; /* Center when stacked */
        }
        .middle-chat-divider {
            order: unset; /* Reset order for stacking */
        }
        /* Adjust icon positions for smaller screens */
        #logoutBtn { right: 10px; }
        #profileIcon { right: 55px; } /* Adjusted for smaller width */
        #inventoryIcon { right: 100px; }
        #shopIcon { right: 145px; }
        #codeInputIcon { right: 190px; }

        .top-right-icon {
            width: 35px;
            height: 35px;
        }
        .top-right-icon svg {
            width: 20px;
            height: 20px;
        }
    }

    @media (max-width: 768px) {
        h1 { font-size: 28px; }
        .game-mode-box, .lobby-card, #authContainer {
            padding: 20px;
        }
        .game-mode-box h3 { font-size: 20px; }
        .lobby-header {
            flex-direction: column; /* Stack items vertically on smaller screens */
            align-items: center; /* Center items horizontally when stacked */
            gap: 10px; /* Maintain gap for vertical stacking */
        }
        .lobby-header button {
            margin: 0; /* Reset margins, gap will handle spacing */
            margin-bottom: 0px;
        }
        .lobby-header h2 {
            font-size: 24px;
            margin: 0; /* Reset margins, gap will handle spacing */
            margin-bottom: 0px;
            white-space: normal; /* Allow title to wrap on smaller screens */
        }
        .question-box, .question-box-1v1 {
            padding: 15px;
            width: 95%;
        }
        .question-box input[type="text"], .question-box-1v1 input[type="text"] {
            width: calc(100% - 60px);
        }
        .player {
            width: 80px;
            height: 80px;
            font-size: 10px;
        }
        .player .name { font-size: 14px; }
        .player .lives { font-size: 10px; }
        #timer { font-size: 36px; }
        #leaderboard, #globalLeaderboard {
            width: 98%;
            padding: 8px;
        }
        #leaderboard th, #leaderboard td, #globalLeaderboard th, #globalLeaderboard td {
            padding: 8px 5px;
            font-size: 12px;
        }
        #leaderboard thead, #globalLeaderboard thead { font-size: 16px; }
        #soloChallengeUI { min-height: 500px; }
        #soloCodeEditor { height: 150px; }
        .custom-modal-content { padding: 20px; }
        .custom-modal-content h3 { font-size: 20px; }
        .custom-modal-content p { font-size: 14px; }
        /* Adjust modal buttons for smaller screens */
        .custom-modal-content button {
            padding: 10px 20px;
            font-size: 16px;
            min-width: 80px;
        }
        .item-card {
            min-height: 180px; /* Adjust card height for smaller screens */
        }
        .item-card img {
            height: 80px;
        }
    }

    /* Styling for Code Input Modal's input field */
    #codeInputModal .custom-modal-content input[type="text"] {
        width: calc(100% - 20px); /* Match auth inputs */
        padding: 12px; /* Match auth inputs */
        margin-bottom: 15px; /* Match auth inputs */
        background-color: black;
        color: #00ccff;
        border: 1px solid #00ccff;
        border-radius: 5px;
        font-size: 16px;
        box-sizing: border-box;
    }
</style>
</head>
<body>
<h1>Code Rivals</h1>

<button id="logoutBtn" class="primary-btn">Logout</button>
<div id="welcomeMessage"></div>

<!-- Profile Icon -->
<div id="profileIcon" class="top-right-icon" onclick="showProfilePage()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
    </svg>
</div>

<!-- New Inventory Icon/Button -->
<div id="inventoryIcon" class="top-right-icon" onclick="showInventory()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
        <path d="M20 6h-4V4c0-1.1-.9-2-2-2h-4c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-6-2h-4v2h4V4zm6 15H4V8h16v11zM9 18c0 .55-.45 1-1 1s-1-.45-1-1V12c0-.55.45-1 1-1s1 .45 1 1v6zm4 0c0 .55-.45 1-1 1s-1-.45-1-1V12c0-.55.45-1 1-1s1 .45 1 1v6zm4 0c0 .55-.45 1-1 1s-1-.45-1-1V12c0-.55.45-1 1-1s1 .45 1 1v6z"/>
    </svg>
</div>

<!-- New Shop Icon/Button -->
<div id="shopIcon" class="top-right-icon" onclick="showShop()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
        <path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2zm-8.7-5.9l.6-3.9h9.1l1.8 3.8-11.2-.5zM17 9c-.75 0-1.42.34-1.87.87L13 14.5V10H7V6H4V4h3c.55 0 1-.45 1-1s-.45-1-1-1H4c-1.1 0-2 .9-2 2v1.5l.5 1H2v11c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V9h-5z"/>
    </svg>
</div>

<!-- New Code Input Icon/Button -->
<div id="codeInputIcon" class="top-right-icon" onclick="showCodeInputModal()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
        <path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>
    </svg>
</div>

<div id="authContainer">
    <h2 id="authTitle">Login</h2>
    <input type="text" id="usernameInput" placeholder="Username" autocomplete="username">
    <input type="password" id="passwordInput" placeholder="Password" autocomplete="current-password">
    <button id="authSubmitBtn" class="primary-btn">Login</button>
    <div id="authSwitch">Don't have an account? Sign Up</div>
</div>

<!-- Main Lobby Dashboard (New Section) -->
<div id="mainLobbyDashboard">
    <div class="main-panel left-panel-modes">
        <h2>Game Modes</h2>
        <button id="casualModeBtn" class="primary-btn">Casual</button>
        <button id="rankedModeBtn" class="primary-btn">Ranked</button>
        <button id="customModeBtn" class="primary-btn">Custom</button>
        <!-- Inventory and Shop buttons moved to top right icons -->
    </div>

    <div class="main-panel center-panel-leaderboard">
        <div id="globalLeaderboard">
            <h2>Global Leaderboard</h2>
            <table>
                <thead><tr><th>Rank</th><th>Player</th><th>ELO</th><th>Accuracy</th></tr></thead>
                <tbody id="globalLeaderboardBody"></tbody>
            </table>
        </div>
    </div>

    <div class="main-panel right-panel-updates"> <!-- Renamed class -->
        <h3>Update Logs</h3>
        <ul id="updates">
            <li>v0.1 - Initial release</li>
            <li>v0.2 - Lobby and Login separation</li>
            <li>v0.3 - Persistent leaderboard (local file system)</li>
            <li>v0.4 - Video background added</li>
            <li>v0.5 - Consolidated frontend logic</li>
            <li>v0.6 - Client-side login/signup, in-memory lobbies</li>
            <li>v0.7 - Hidden ranked lobbies with mode selection</li>
            <li>v0.8 - Direct entry to ranked lobbies, all players visible in-game, auto ready-up for ranked.</li>
            <li>v0.9 - Inventory, Shop, and Token system added. ELO system adjusted.</li>
            <li>v1.0 - Inventory and Shop moved to top icons.</li>
            <li>v1.1 - Added Code Input feature for tokens.</li>
            <li>v1.2 - Styled Code Input and ensured Inventory updates.</li>
            <li>v1.3 - Debugged "Failed to fetch" error for local-only operation.</li>
            <li>v1.4 - Added Profile page, casual points, shop categories, bot accuracy logic.</li>
            <li>v1.5 - Implemented Custom Mode with Frenzy Mode, Ability Cards, and adjustable timers.</li>
            <li>v1.6 - Frenzy mode players start with 3 cards. Profile rank added based on accuracy.</li>
            <li>v1.7 - Integrated Gemini API for solo challenge code evaluation.</li>
        </ul>
    </div>
</div>


<div id="gameModeSelection">
    <h2>Choose Your Casual Game Mode</h2>
    <div class="game-mode-box" id="four-v-four-qna-mode">
        <h3>Free for All Q&A</h3>
        <p>Compete with up to 4 players in a fast-paced Q&A challenge.</p>
    </div>
    <div class="game-mode-box" id="one-v-one-fill-in-blanks-mode">
        <h3>1v1 Fill in the Blanks</h3>
        <p>A head-to-head battle, filling in missing code for C++ beginners.</p>
    </div>
    <div class="game-mode-box" id="solo-coding-challenge-mode">
        <h3>Solo Coding Challenge</h3>
        <p>Improve your skills by solving C++ problems, evaluated by AI.</p>
    </div>
    <button class="back-to-dashboard-btn primary-btn">Back to Dashboard</button>
</div>

<!-- New Ranked Game Mode Selection -->
<div id="rankedGameModeSelection">
    <h2>Choose Your Ranked Game Mode</h2>
    <div class="game-mode-box" id="ranked-four-v-four-qna-mode">
        <h3>Ranked Free for All Q&A</h3>
        <p>Compete in a ranked 4-player Q&A match to climb the leaderboard.</p>
    </div>
    <div class="game-mode-box" id="ranked-one-v-one-fill-in-blanks-mode">
        <h3>Ranked 1v1 Fill in the Blanks</h3>
        <p>A ranked head-to-head battle, filling in missing code for ELO.</p>
    </div>
    <button class="back-to-dashboard-btn primary-btn">Back to Dashboard</button>
</div>

<!-- Profile Page -->
<div id="profilePage" class="game-section-container">
    <button class="back-to-dashboard-btn primary-btn" style="align-self: flex-start; margin-bottom: 20px;">Back to Dashboard</button>
    <div id="profileHeader">
        <div id="profileAvatar">
            <!-- User's first initial or custom avatar -->
            <span id="profileAvatarText">U</span>
        </div>
        <h2 id="profileUsernameDisplay">PlayerName</h2>
    </div>

    <div id="profileStatsGrid">
        <div class="stat-item">
            <h4>Ranked ELO</h4>
            <p id="profileRankedElo">0</p>
        </div>
        <div class="stat-item">
            <h4>Rank</h4>
            <p id="profileRankDisplay">D</p> <!-- New element for rank display -->
        </div>
        <div class="stat-item">
            <h4>Casual Points</h4>
            <p id="profileCasualPoints">0</p>
        </div>
        <div class="stat-item">
            <h4>Ranked Accuracy</h4>
            <p id="profileRankedAccuracy">0%</p>
        </div>
        <div class="stat-item">
            <h4>Casual Accuracy</h4>
            <p id="profileCasualAccuracy">0%</p>
        </div>
        <div class="stat-item">
            <h4>Solo Stages Cleared</h4>
            <p id="profileSoloStages">0</p>
        </div>
        <div class="stat-item">
            <h4>Tokens</h4>
            <p id="profileTokens">0</p>
        </div>
    </div>

    <div id="profileSections">
        <div id="profileTitles" class="profile-section-box">
            <h3>Titles</h3>
            <p id="profileEquippedTitle">No Title Equipped</p>
            <!-- List of owned titles could go here -->
        </div>
        <div id="profileAchievements" class="profile-section-box">
            <h3>Achievements</h3>
            <ul>
                <li>First Win</li>
                <li>5 Wins</li>
                <li>10 Wins</li>
                <li>Master Debugger (Solo Stage 5)</li>
                <li>Code Rival (ELO 1500)</li>
                <!-- More achievements can be added dynamically -->
            </ul>
        </div>
        <div id="profileInventoryList" class="profile-section-box">
            <h3>Owned Cosmetics</h3>
            <ul>
                <!-- Owned cosmetic items will be listed here -->
            </ul>
        </div>
    </div>
</div>

<!-- Inventory Container -->
<div id="inventoryContainer" class="game-section-container">
    <h2>Your Inventory</h2>
    <p id="inventoryTokenDisplay">Tokens: <span id="inventoryCurrentTokens">0</span></p>
    <div id="inventoryGrid" class="item-grid">
        <!-- Inventory items will be dynamically loaded here -->
        <p style="color: #ccc; text-align: center; width: 100%;">No items in your inventory yet!</p>
    </div>
    <button class="back-to-dashboard-btn primary-btn" style="margin-top: 20px;">Back to Dashboard</button>
</div>

<!-- Shop Container -->
<div id="shopContainer" class="game-section-container">
    <h2>Code Rivals Store</h2>
    <p id="shopTokenDisplay">Your Tokens: <span id="shopCurrentTokens">0</span></p>
    <div class="shop-category-buttons">
        <button class="primary-btn active" data-category="all">All</button>
        <button class="primary-btn" data-category="skin">Skins</button>
        <button class="primary-btn" data-category="emote">Emotes</button>
        <button class="primary-btn" data-category="icon">Icons</button>
        <button class="primary-btn" data-category="title">Titles</button>
        <button class="primary-btn" data-category="utility">Utility</button>
    </div>
    <div id="shopGrid" class="item-grid">
        <!-- Shop items will be dynamically loaded here -->
    </div>
    <button class="back-to-dashboard-btn primary-btn" style="margin-top: 20px;">Back to Dashboard</button>
</div>


<!-- Lobby List Container -->
<div id="lobbyListContainer" class="lobby-list-container">
    <div class="lobby-header">
        <button class="back-to-mode-selection-btn primary-btn">Back to Mode Select</button>
        <h2 id="lobbyListTitle">Available Lobbies</h2>
        <button class="primary-btn" id="createNewLobbyBtn">Create New Lobby</button>
    </div>
    <div id="lobbiesGrid" class="lobby-grid">
        <!-- Lobbies will be dynamically loaded here -->
    </div>
</div>

<!-- Single Lobby View -->
<div id="singleLobbyView" class="lobby-list-container">
    <div class="lobby-header">
        <button class="back-to-lobbies-btn primary-btn">Leave Lobby</button>
        <h2 id="currentLobbyTitle"></h2>
        <button id="readyToggleBtn" class="primary-btn">Ready Up!</button>
    </div>
    <p id="currentLobbyInfo">Lobby ID: <span id="displayLobbyId"></span> | Players: <span id="displayPlayerCount">0</span>/<span id="displayMaxPlayers">0</span> | Status: <span id="displayLobbyStatus"></span></p>
    <div id="lobbyPlayersDisplay" class="lobby-grid">
        <!-- Players in the current lobby will be displayed here -->
    </div>
    <button id="startGameButton" class="primary-btn" disabled>Start Game</button>
</div>


<div class="main-content-wrapper">
    <div id="gameUI">
        <!-- Layout specific to 4v4 Q&A -->
        <div id="four-v-four-qna-layout">
            <div class="multiplayer-game-area"> <!-- New wrapper div -->
                <div class="game-container">
                    <button id="backToLobbyBtn4v4" class="primary-btn">Back to Lobbies</button>
                    <div class="player-circle" id="playerCircle"></div>
                    <div id="timer">30</div>
                    <div id="questionBox4v4" class="question-box">
                        <p id="question4v4">Loading...</p>
                        <input type="text" id="answerInput4v4" placeholder="Your answer here" />
                        <button id="submitAnswerBtn4v4">Submit</button>
                    </div>
                </div>
                <div id="chatBox4v4" class="chat-box-layout">
                    <h3>Lobby Chat</h3>
                    <div id="chatMessages4v4" class="chat-messages"></div>
                    <input type="text" id="chatInput4v4" placeholder="Type your message..." />
                    <button id="sendChatBtn4v4">Send</button>
                </div>
            </div>
            <!-- Player cards container for 4v4 -->
            <div id="playerCardsContainer4v4" class="player-cards-container">
                <!-- Cards will be rendered here -->
            </div>
            <!-- Ranking Area (common for multiplayer) -->
            <div class="ranking-area">
                <div id="leaderboard">
                    <h2>Current Round Leaderboard</h2>
                    <table>
                        <thead><tr><th>Rank</th><th>Player</th><th>ELO</th><th>Accuracy</th></tr></thead>
                        <tbody id="leaderboardBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Layout specific to 1v1 Fill-in-the-Blanks -->
        <div id="one-v-one-fill-in-blanks-layout">
            <button id="backToLobbyBtn1v1" class="primary-btn">Back to Lobbies</button>
            <div class="side-by-side-game-area">
                <div class="player-panels-wrapper"> <!-- New wrapper for player panels -->
                    <div class="player-panel" id="player1-panel">
                        <h3 class="player-panel-name"><span id="player1-name"></span> <span id="player1-you-tag"></span></h3>
                        <p>Lives: <span id="player1-lives"></span></p>
                        <p>Ranked ELO: <span id="player1-elo"></span></p>
                        <p>Casual Points: <span id="player1-points"></span></p>
                        <div id="questionBox1v1Player1" class="question-box-1v1">
                             <p id="question1v1Player1"></p>
                             <input type="text" id="answerInput1v1Player1" placeholder="Your answer here" />
                             <button id="submitAnswerBtn1v1Player1">Submit</button>
                        </div>
                    </div>
                    <div class="player-panel" id="player2-panel">
                        <h3 class="player-panel-name"><span id="player2-name"></span> <span id="player2-you-tag"></span></h3>
                        <p>Lives: <span id="player2-lives"></span></p>
                        <p>Ranked ELO: <span id="player2-elo"></span></p>
                        <p>Casual Points: <span id="player2-points"></span></p>
                        <div id="questionBox1v1Player2" class="question-box-1v1">
                             <p id="question1v1Player2"></p>
                             <input type="text" id="answerInput1v1Player2" placeholder="Your answer here" />
                             <button id="submitAnswerBtn1v1Player2">Submit</button>
                        </div>
                    </div>
                </div>
                <div id="chatBox1v1" class="chat-box-layout middle-chat-divider">
                    <h3>Lobby Chat</h3>
                    <div id="chatMessages1v1" class="chat-messages"></div>
                    <input type="text" id="chatInput1v1" placeholder="Type your message..." />
                    <button id="sendChatBtn1v1">Send</button>
                </div>
            </div>
            <!-- Player cards container for 1v1 -->
            <div id="playerCardsContainer1v1" class="player-cards-container">
                <!-- Cards will be rendered here -->
            </div>
            <!-- Ranking Area (common for multiplayer) -->
            <div class="ranking-area">
                <div id="leaderboard">
                    <h2>Current Round Leaderboard</h2>
                    <table>
                        <thead><tr><th>Rank</th><th>Player</th><th>ELO</th><th>Accuracy</th></tr></thead>
                        <tbody id="leaderboardBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="replay-button" id="replayButton">
            <button class="primary-btn">Replay</button>
        </div>
    </div>

    <!-- Solo Challenge UI -->
    <div id="soloChallengeUI">
        <button id="soloBackToLobbyBtn" class="primary-btn">Back to Mode Select</button>
        <h2>Solo Coding Challenge - Stage <span id="soloCurrentStage">1</span></h2>
        <div id="soloProblemDescription"></div>
        <textarea id="soloCodeEditor" placeholder="Write your C++ code here..."></textarea>
        <div id="soloChallengeButtons">
            <button id="soloPrevStageBtn" class="primary-btn" disabled>Previous Stage</button>
            <button id="runCodeBtn" class="primary-btn">Run Code</button>
            <button id="soloNextStageBtn" class="primary-btn" disabled>Next Stage</button>
        </div>
        <div id="soloLoadingIndicator">Evaluating code...</div>
        <div id="soloResult"></div>
    </div>
</div>

<div id="customModal" class="custom-modal">
    <div class="custom-modal-content">
        <h3 id="modalTitle"></h3>
        <p id="modalMessage"></p>
        <button class="primary-btn">OK</button> <!-- Added primary-btn class -->
    </div>
</div>

<div id="createLobbyModal" class="custom-modal">
    <div class="custom-modal-content">
        <h3>Create New Lobby</h3>
        <label for="new-lobby-name">Lobby Name:</label>
        <input type="text" id="new-lobby-name" placeholder="Enter lobby name" required>

        <label for="new-lobby-max-players">Max Players:</label>
        <select id="new-lobby-max-players">
            <!-- Options will be dynamically populated by JavaScript -->
        </select>

        <label for="initial-lives-select">Initial Lives:</label>
        <select id="initial-lives-select">
            <option value="3">3 Lives (Default)</option>
            <option value="4">4 Lives</option>
            <option value="5">5 Lives</option>
        </select>

        <label for="question-timer-select">Question Timer (seconds):</label>
        <select id="question-timer-select">
            <option value="15">15 Seconds</option>
            <option value="30">30 Seconds (Default)</option>
            <option value="45">45 Seconds</option>
            <option value="60">60 Seconds</option>
        </select>

        <label class="checkbox-container">
            <input type="checkbox" id="frenzy-mode-toggle">
            Frenzy Mode (Enable Ability Cards)
        </label>

        <div class="modal-buttons">
            <button class="primary-btn" id="confirmCreateLobbyBtn">Create</button>
            <button class="primary-btn" id="cancelCreateLobbyBtn">Cancel</button>
        </div>
    </div>
</div>

<!-- New Code Input Modal -->
<div id="codeInputModal" class="custom-modal">
    <div class="custom-modal-content">
        <h3>Enter Code</h3>
        <label for="codeInput">Code:</label>
        <input type="text" id="codeInput" placeholder="Enter your code here" autocomplete="off">
        <div class="modal-buttons">
            <button class="primary-btn" id="redeemCodeBtn">Redeem</button>
            <button class="primary-btn" id="cancelCodeBtn">Cancel</button>
        </div>
    </div>
</div>

<!-- Meta Vision Overlay -->
<div id="metaVisionOverlay" class="custom-modal">
    <div id="metaVisionContent" class="custom-modal-content">
        <h3>Meta Vision: Opponent Decks</h3>
        <div id="metaVisionPlayerDecks">
            <!-- Player decks will be rendered here -->
        </div>
        <button class="primary-btn" onclick="closeMetaVision()">Close</button>
    </div>
</div>


<script>
    // Global game state variables
    let currentUser = null; // Stores currently logged-in user's data from in-memory 'users' object
    let userId = null; // Unique ID for the current user (from in-memory 'users' object)
    let currentLobbyType = ''; // '4v4-qna', '1v1-fill-in-blanks', 'solo-coding-challenge', 'custom-qna', 'custom-fill-in-blanks'
    let currentLobbyId = ''; // ID of the currently joined lobby
    let isRankedMatch = false; // Flag to indicate if the current game is ranked
    let isCustomMatch = false; // Flag to indicate if the current game is custom

    // In-memory "database" for user credentials and stats (NO PERSISTENCE ACROSS BROWSER SESSIONS)
    // Stores { username: { id: "uniqueId", password: "password", soloStage: 0,
    //                      rankedCorrectAnswers: 0, rankedTotalAnswers: 0, elo: 0,
    //                      casualCorrectAnswers: 0, casualTotalAnswers: 0, casualPoints: 0,
    //                      tokens: 0, inventory: [], equippedTitle: '...' } }
    const users = {};
    let nextUserId = 1; // Simple counter for unique user IDs for in-memory users

    // In-memory "database" for active lobbies (NO PERSISTENCE ACROSS BROWSER SESSIONS)
    // Stores { lobbyId: { id: "...", name: "...", type: "...", players: [], maxPlayers: N, gameStarted: false, chatMessages: [],
    //                      isRanked: false, isFrenzyMode: false, initialLives: 3, questionTimer: 30, playerCycles: 0 } }
    const activeLobbies = {};

    let players = []; // Local array of players in the current game (multiplayer modes)
    let isPlayerReady = false; // Current user's ready status in the current lobby

    // Game variables for Q&A / Fill-in-the-blanks modes
    let questions = []; // Questions for the current game round
    let currentQuestionIndex = 0; // Index of the current question
    let currentPlayerIndex = 0; // Index of the player whose turn it is
    let timeLeft = 30; // Time left for current question (will be overridden by lobby setting)
    let timer; // Interval ID for the game timer
    let playerCycles = 0; // Tracks total player turns for card distribution

    // Solo Challenge variables
    let currentSoloStage = 0; // Index for soloChallenges array - will be loaded from user data

    // Bot accuracy settings
    const BOT_ACCURACY_MULTIPLAYER = 0.7; // 70% chance for bots to be correct in multiplayer
    const BOT_ACCURACY_SOLO = 1.0; // 100% chance for bots to be correct in solo (simulated AI)

    // Pre-defined game questions
    const originalQuestions = [
        { q: "What is the output of: cout << 2 + 2;", a: "4" },
        { q: "Which keyword is used for constant?", a: "const" },
        { q: "How many bytes is an int?", a: "4" },
        { q: "C++ pointer access operator?", a: "->" },
        { q: "Declare a pointer to int", a: "int* ptr;" }
    ];

    const fillInBlanksQuestions = [
        { q: "int main() { cout << \"Hello, ___\"; return 0; }", a: "world", hint: "Common greeting" },
        { q: "int ___ = 10;", a: "x", hint: "A common variable name" },
        { q: "for (int i = 0; i < ___; i++)", a: "10", hint: "A typical loop limit" },
        { q: "class MyClass { public: MyClass() { /* constructor */ } };", a: "MyClass", hint: "Name of the class" },
        { q: "std::string ___ = \"C++\";", a: "language", hint: "What is C++?" }
    ];

    // Solo Coding Challenges
    const soloChallenges = [
        {
            stage: 1,
            title: "Hello World!",
            problem: "Write a C++ program that prints 'Hello, World!' to the console. The output must exactly match 'Hello, World!' followed by a newline.",
            expectedOutput: "Hello, World!\n",
            initialCode: `#include <iostream>\n\nint main() {\n  std::cout << "Hello, World!" << std::endl;\n  return 0;\n}`
        },
        {
            stage: 2,
            title: "Add Two Numbers",
            problem: "Write a C++ program that declares two integer variables, `a` and `b`, initializes them to 5 and 7 respectively, and prints their sum to the console. The output must be exactly '12' followed by a newline.",
            expectedOutput: "12\n",
            initialCode: `#include <iostream>\n\nint main() {\n  int a = 5;\n  int b = 7;\n  std::cout << (a + b) << std::endl;\n  return 0;\n}`
        },
        {
            stage: 3,
            title: "Conditional Statement (If-Else)",
            problem: "Write a C++ program that declares an integer variable `num` and initializes it to 10. If `num` is greater than 5, print 'Greater than 5'; otherwise, print 'Not greater than 5'. The output must be exactly 'Greater than 5' followed by a newline.",
            expectedOutput: "Greater than 5\n",
            initialCode: `#include <iostream>\n\nint main() {\n  int num = 10;\n  if (num > 5) {\n    std::cout << "Greater than 5" << std::endl;\n  } else {\n    std::cout << "Not greater than 5" << std::endl;\n  }\n  return 0;\n}`
        },
        {
            stage: 4,
            title: "Simple Loop (For loop)",
            problem: "Write a C++ program that uses a for loop to print numbers from 1 to 3, each on a new line. The output must be exactly '1\\n2\\n3\\n'.",
            expectedOutput: "1\n2\n3\n",
            initialCode: `#include <iostream>\n\nint main() {\n  for (int i = 1; i <= 3; ++i) {\n    std::cout << i << std::endl;\n  }\n  return 0;\n}`
        },
        {
            stage: 5,
            title: "Basic Function",
            problem: "Write a C++ program with a function named `add` that takes two integers as parameters and returns their sum. In `main`, call `add` with 15 and 20 and print the result. The output must be exactly '35' followed by a newline.",
            expectedOutput: "35\n",
            initialCode: `#include <iostream>\n\nint add(int a, int b) {\n  return a + b;\n}\n\nint main() {\n  std::cout << add(15, 20) << std::endl;\n  return 0;\n}\n`
        },
        {
            stage: 6,
            title: "Factorial Calculation",
            problem: "Write a C++ program to calculate the factorial of a number (e.g., 5). Print the result. The output must be exactly '120' followed by a newline. (Factorial of 5 is 5*4*3*2*1 = 120)",
            expectedOutput: "120\n",
            initialCode: `#include <iostream>\n\nint main() {\n  int n = 5;\n  long long factorial = 1;\n\n  for (int i = 1; i <= n; ++i) {\n    factorial *= i;\n  }\n\n  std::cout << factorial << std::endl;\n  return 0;\n}`
        },
        {
            stage: 7,
            title: "Array Sum",
            problem: "Write a C++ program that initializes an integer array with values {10, 20, 30}. Calculate the sum of its elements and print the sum. The output must be exactly '60' followed by a newline.",
            expectedOutput: "60\n",
            initialCode: `#include <iostream>\n#include <vector>\n\nint main() {\n  std::vector<int> numbers = {10, 20, 30};\n  int sum = 0;\n\n  for (int num : numbers) {\n    sum += num;\n}\n\n  std::cout << sum << std::endl;\n  return 0;\n}`
        }
    ];

    // Inventory and Shop Data
    const shopItems = [
        { id: 'skin_syntax_sorcerer', name: 'Syntax Sorcerer', description: 'Master of clean code. Grants 10% bonus ELO in casual matches.', price: 500, type: 'skin', category: 'skin', imageUrl: 'https://placehold.co/150x100/003366/00ccff?text=Syntax+Sorcerer' },
        { id: 'skin_binary_blade', name: 'Binary Blade', description: 'Wield the power of 0s and 1s. Looks cool.', price: 750, type: 'skin', category: 'skin', imageUrl: 'https://placehold.co/150x100/003366/00ccff?text=Binary+Blade' },
        { id: 'emote_debug_dance', name: 'Debug Dance', description: 'Celebrate bug fixes with style. Emote.', price: 200, type: 'emote', category: 'emote', imageUrl: 'https://placehold.co/150x100/003366/00ccff?text=Debug+Dance' },
        { id: 'icon_cpp_logo', name: 'C++ Icon', description: 'Show your C++ pride. Profile icon.', price: 100, type: 'icon', category: 'icon', imageUrl: 'https://placehold.co/150x100/003366/00ccff?text=C%2B%2B+Icon' },
        { id: 'skin_compiler_commander', name: 'Compiler Commander', description: 'Command your code to compile flawlessly. Legendary skin.', price: 1200, type: 'skin', category: 'skin', imageUrl: 'https://placehold.co/150x100/003366/00ccff?text=Compiler+Commander' },
        { id: 'emote_infinite_loop', name: 'Infinite Loop', description: 'A never-ending dance. Use with caution.', price: 300, type: 'emote', category: 'emote', imageUrl: 'https://placehold.co/150x100/003366/00ccff?text=Infinite+Loop' },
        { id: 'title_code_master', name: 'Code Master', description: 'A title for those who truly understand code.', price: 1500, type: 'title', category: 'title', imageUrl: 'https://placehold.co/150x100/003366/00ccff?text=Code+Master' },
        { id: 'title_bug_hunter', name: 'Bug Hunter', description: 'Awarded for finding and squashing many bugs.', price: 800, type: 'title', category: 'title', imageUrl: 'https://placehold.co/150x100/003366/00ccff?text=Bug+Hunter' },
        { id: 'utility_xp_boost', name: 'XP Boost (1hr)', description: 'Doubles ELO/Points gain for 1 hour.', price: 400, type: 'utility', category: 'utility', imageUrl: 'https://placehold.co/150x100/003366/00ccff?text=XP+Boost' }
    ];

    // Ability Card Definitions (exclusive to Custom Mode with Frenzy)
    const abilityCards = [
        { id: 'card_copy', name: 'Copy', description: 'Copy 1 card from another player (randomly chosen from available types).', icon: '<svg class="card-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>' },
        { id: 'card_control', name: 'Control', description: 'Skip your turn to play safe, or pick another player to start their turn.', icon: '<svg class="card-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z"/></svg>' },
        { id: 'card_golden_defense', name: 'Golden Defense', description: 'Gain 2 shields. Incorrect answers deduct shield instead of life. Max 2 shields, one-time use per game.', icon: '<svg class="card-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.76-7 8.94V12H5V6.3l7-3.11v8.79z"/></svg>' },
        { id: 'card_meta_vision', name: 'Meta Vision', description: 'See your opponents\' hands (current cards).', icon: '<svg class="card-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>' },
        { id: 'card_evolved_meta_vision', name: 'Evolved Meta Vision', description: 'Receive a clue for the current question.', icon: '<svg class="card-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>' }
    ];


    // --- DOM Element References ---

    const authContainer = document.getElementById('authContainer');
    const gameModeSelection = document.getElementById('gameModeSelection');
    const rankedGameModeSelection = document.getElementById('rankedGameModeSelection'); // New reference
    const mainLobbyDashboard = document.getElementById('mainLobbyDashboard'); // New reference
    const lobbyListContainer = document.getElementById('lobbyListContainer');
    const singleLobbyView = document.getElementById('singleLobbyView');
    const mainContentWrapper = document.querySelector('.main-content-wrapper');
    const gameUI = document.getElementById('gameUI');
    const soloChallengeUI = document.getElementById('soloChallengeUI');
    const inventoryContainer = document.getElementById('inventoryContainer'); // New Inventory container
    const shopContainer = document.getElementById('shopContainer'); // New Shop container
    const profilePage = document.getElementById('profilePage'); // New Profile page reference

    const logoutBtn = document.getElementById('logoutBtn');
    const welcomeMessage = document.getElementById('welcomeMessage');
    const profileIcon = document.getElementById('profileIcon'); // Get reference to the profile icon
    const inventoryIcon = document.getElementById('inventoryIcon'); // New Inventory icon reference
    const shopIcon = document.getElementById('shopIcon'); // New Shop icon reference
    const codeInputIcon = document.getElementById('codeInputIcon'); // New Code Input icon reference

    const usernameInput = document.getElementById('usernameInput');
    const passwordInput = document.getElementById('passwordInput');
    const authTitle = document.getElementById('authTitle');
    const authSubmitBtn = document.getElementById('authSubmitBtn');
    const authSwitch = document.getElementById('authSwitch');

    const modalTitle = document.getElementById('modalTitle');
    const modalMessage = document.getElementById('modalMessage');
    const customModal = document.getElementById('customModal');
    const customModalOkBtn = customModal.querySelector('button');

    const createLobbyModal = document.getElementById('createLobbyModal');
    const newLobbyNameInput = document.getElementById('new-lobby-name');
    const newLobbyMaxPlayersSelect = document.getElementById('new-lobby-max-players');
    const initialLivesSelect = document.getElementById('initial-lives-select'); // New
    const questionTimerSelect = document.getElementById('question-timer-select'); // New
    const frenzyModeToggle = document.getElementById('frenzy-mode-toggle'); // New
    const confirmCreateLobbyBtn = document.getElementById('confirmCreateLobbyBtn');
    const cancelCreateLobbyBtn = document.getElementById('cancelCreateLobbyBtn');

    const codeInputModal = document.getElementById('codeInputModal'); // New Code Input Modal
    const codeInput = document.getElementById('codeInput'); // Code Input field
    const redeemCodeBtn = document.getElementById('redeemCodeBtn'); // Redeem Code button
    const cancelCodeBtn = document.getElementById('cancelCodeBtn'); // Cancel Code button

    const lobbiesGrid = document.getElementById('lobbiesGrid');
    const lobbyListTitle = document.getElementById('lobbyListTitle');
    const currentLobbyTitle = document.getElementById('currentLobbyTitle');
    const displayLobbyId = document.getElementById('displayLobbyId');
    const displayPlayerCount = document.getElementById('displayPlayerCount');
    const displayMaxPlayers = document.getElementById('displayMaxPlayers');
    const displayLobbyStatus = document.getElementById('displayLobbyStatus');
    const lobbyPlayersDisplay = document.getElementById('lobbyPlayersDisplay');
    const readyToggleBtn = document.getElementById('readyToggleBtn');
    const startGameButton = document.getElementById('startGameButton');
    const createNewLobbyBtn = document.getElementById('createNewLobbyBtn'); // Added reference

    const fourVFourQnALayout = document.getElementById('four-v-four-qna-layout');
    const oneVOneFillInBlanksLayout = document.getElementById('one-v-one-fill-in-blanks-layout');
    const playerCircleDiv = document.getElementById('playerCircle');
    const gameTimerDisplay = document.getElementById('timer');
    const question4v4Display = document.getElementById('question4v4');
    const answerInput4v4 = document.getElementById('answerInput4v4');
    const submitAnswerBtn4v4 = document.getElementById('submitAnswerBtn4v4');
    const replayButton = document.getElementById('replayButton');

    const player1Panel = document.getElementById('player1-panel');
    const player2Panel = document.getElementById('player2-panel');
    const player1Name = document.getElementById('player1-name');
    const player1YouTag = document.getElementById('player1-you-tag');
    const player1Lives = document.getElementById('player1-lives');
    const player1Elo = document.getElementById('player1-elo');
    const player1Points = document.getElementById('player1-points'); // New for casual points
    const player2Name = document.getElementById('player2-name');
    const player2YouTag = document.getElementById('player2-you-tag');
    const player2Lives = document.getElementById('player2-lives');
    const player2Elo = document.getElementById('player2-elo');
    const player2Points = document.getElementById('player2-points'); // New for casual points
    const questionBox1v1Player1 = document.getElementById('questionBox1v1Player1');
    const question1v1Player1 = document.getElementById('question1v1Player1');
    const answerInput1v1Player1 = document.getElementById('answerInput1v1Player1');
    const submitAnswerBtn1v1Player1 = document.getElementById('submitAnswerBtn1v1Player1');
    const questionBox1v1Player2 = document.getElementById('questionBox1v1Player2');
    const question1v1Player2 = document.getElementById('question1v1Player2');
    const answerInput1v1Player2 = document.getElementById('answerInput1v1Player2');
    const submitAnswerBtn1v1Player2 = document.getElementById('submitAnswerBtn1v1Player2');


    const soloCurrentStageSpan = document.getElementById('soloCurrentStage');
    const soloProblemDescription = document.getElementById('soloProblemDescription');
    const soloCodeEditor = document.getElementById('soloCodeEditor');
    const soloPrevStageBtn = document.getElementById('soloPrevStageBtn');
    const soloNextStageBtn = document.getElementById('soloNextStageBtn');
    const runCodeBtn = document.getElementById('runCodeBtn');
    const soloLoadingIndicator = document.getElementById('soloLoadingIndicator');
    const soloResult = document.getElementById('soloResult');

    const chatMessages4v4Div = document.getElementById('chatMessages4v4');
    const chatInput4v4 = document.getElementById('chatInput4v4');
    const sendChatBtn4v4 = document.getElementById('sendChatBtn4v4');
    const chatBox4v4 = document.getElementById('chatBox4v4');

    const chatMessages1v1Div = document.getElementById('chatMessages1v1');
    const chatInput1v1 = document.getElementById('chatInput1v1');
    const sendChatBtn1v1 = document.getElementById('sendChatBtn1v1');
    const chatBox1v1 = document.getElementById('chatBox1v1');

    const leaderboardBody = document.getElementById('leaderboardBody');
    const globalLeaderboardBody = document.getElementById('globalLeaderboardBody');

    const backToDashboardBtns = document.querySelectorAll('.back-to-dashboard-btn');

    const inventoryCurrentTokens = document.getElementById('inventoryCurrentTokens');
    const shopCurrentTokens = document.getElementById('shopCurrentTokens');

    // Profile page elements
    const profileAvatarText = document.getElementById('profileAvatarText');
    const profileUsernameDisplay = document.getElementById('profileUsernameDisplay');
    const profileRankedElo = document.getElementById('profileRankedElo');
    const profileRankDisplay = document.getElementById('profileRankDisplay'); // New: Rank display
    const profileCasualPoints = document.getElementById('profileCasualPoints');
    const profileRankedAccuracy = document.getElementById('profileRankedAccuracy');
    const profileCasualAccuracy = document.getElementById('profileCasualAccuracy');
    const profileSoloStages = document.getElementById('profileSoloStages');
    const profileTokens = document.getElementById('profileTokens');
    const profileEquippedTitle = document.getElementById('profileEquippedTitle');
    const profileInventoryList = document.getElementById('profileInventoryList').querySelector('ul');
    const shopCategoryButtons = document.querySelectorAll('.shop-category-buttons button');

    // Card UI elements
    const playerCardsContainer4v4 = document.getElementById('playerCardsContainer4v4');
    const playerCardsContainer1v1 = document.getElementById('playerCardsContainer1v1');
    const metaVisionOverlay = document.getElementById('metaVisionOverlay');
    const metaVisionPlayerDecks = document.getElementById('metaVisionPlayerDecks');


    // --- Utility Functions ---

    let resolveModalPromise;

    /**
     * Displays a custom modal message. Can be used as an alert or a confirmation.
     * @param {string} title The title of the modal.
     * @param {string} message The message content.
     * @param {boolean} isConfirm If true, adds a "Cancel" button and returns a Promise resolving to true/false.
     * @returns {Promise<boolean>} Resolves to true for OK/Confirm, false for Cancel.
     */
    function showCustomModal(title, message, isConfirm = false) {
        return new Promise((resolve) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;

            // Remove any old "Cancel" button before adding new ones
            const oldCancelButton = customModalOkBtn.parentNode.querySelector('.cancel-button');
            if (oldCancelButton) {
                oldCancelButton.remove();
            }

            if (isConfirm) {
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.className = 'primary-btn cancel-button'; // Use primary-btn class
                cancelButton.style.backgroundColor = '#666';
                cancelButton.style.borderColor = '#999';
                cancelButton.style.marginLeft = '10px';
                cancelButton.onclick = () => {
                    closeModal();
                    resolve(false); // Resolve with false for cancel
                };
                customModalOkBtn.parentNode.insertBefore(cancelButton, customModalOkBtn.nextSibling);
                customModalOkBtn.textContent = 'Confirm';
                customModalOkBtn.onclick = () => {
                    closeModal();
                    resolve(true); // Resolve with true for confirm
                };
            } else {
                customModalOkBtn.textContent = 'OK';
                customModalOkBtn.onclick = () => {
                    closeModal();
                    resolve(true); // Resolve with true for OK
                };
            }
            resolveModalPromise = resolve; // Store resolve function for direct calls to closeModal
            customModal.style.display = 'flex';
        });
    }

    /**
     * Hides the custom modal.
     */
    function closeModal() {
        customModal.style.display = 'none';
        // If a promise is pending, resolve it when modal is closed directly
        if (resolveModalPromise) {
            resolveModalPromise(true); // Assume OK if closed without explicit button click
            resolveModalPromise = null;
        }
    }

    /**
     * Shows a specific section and hides others. Manages main-content-wrapper and chatbox visibility.
     * @param {HTMLElement} sectionElement The section DOM element to show.
     */
    function showSection(sectionElement) {
        const sections = [authContainer, gameModeSelection, rankedGameModeSelection, mainLobbyDashboard, lobbyListContainer, singleLobbyView, gameUI, soloChallengeUI, inventoryContainer, shopContainer, codeInputModal, profilePage];
        sections.forEach(sec => {
            if (sec) {
                sec.style.display = 'none';
            }
        });

        if (sectionElement) {
            sectionElement.style.display = 'flex'; // Most sections are flex containers
        }

        // Adjust main-content-wrapper display based on the active section
        if (sectionElement === gameUI || sectionElement === soloChallengeUI || sectionElement === mainLobbyDashboard || sectionElement === inventoryContainer || sectionElement === shopContainer || sectionElement === profilePage) {
            mainContentWrapper.style.display = 'flex';
        } else {
            mainContentWrapper.style.display = 'none'; // Hide main wrapper if not in game/solo/inventory/shop/profile mode
        }

        // Hide all specific game layouts and chat boxes when switching sections
        fourVFourQnALayout.style.display = 'none';
        oneVOneFillInBlanksLayout.style.display = 'none';
        chatBox4v4.style.display = 'none'; // Ensure these are hidden when changing sections
        chatBox1v1.style.display = 'none'; // Ensure these are hidden when changing sections
        playerCardsContainer4v4.style.display = 'none'; // Hide card containers
        playerCardsContainer1v1.style.display = 'none'; // Hide card containers


        // Manage visibility of 'Create New Lobby' button based on section
        if (sectionElement === lobbyListContainer && !currentLobbyType.startsWith('ranked-')) {
            createNewLobbyBtn.style.display = 'block';
        } else {
            createNewLobbyBtn.style.display = 'none';
        }

        // Show/hide top-right icons (logout, profile, inventory, shop, codeInput) based on mainLobbyDashboard or related sections
        const showTopIcons = (sectionElement === mainLobbyDashboard || sectionElement === inventoryContainer || sectionElement === shopContainer || sectionElement === profilePage);
        if (profileIcon) {
            profileIcon.style.display = showTopIcons ? 'flex' : 'none';
        }
        if (logoutBtn) { // Ensure logout button is also controlled
            logoutBtn.style.display = showTopIcons && currentUser ? 'block' : 'none'; // Only show logout if logged in
        }
        if (inventoryIcon) {
            inventoryIcon.style.display = showTopIcons ? 'flex' : 'none';
        }
        if (shopIcon) {
            shopIcon.style.display = showTopIcons ? 'flex' : 'none';
        }
        if (codeInputIcon) {
            codeInputIcon.style.display = showTopIcons ? 'flex' : 'none';
        }
    }

    // --- Authentication Functions (In-Memory Client-Side) ---
    let isLoginMode = true; // true for login, false for signup

    /**
     * Toggles the authentication form between Login and Sign Up modes.
     */
    function toggleAuthMode() {
        isLoginMode = !isLoginMode;
        authTitle.textContent = isLoginMode ? "Login" : "Sign Up";
        authSubmitBtn.textContent = isLoginMode ? "Login" : "Sign Up";
        authSwitch.textContent = isLoginMode ? "Don't have an account? Sign Up" : "Already have an account? Login";
        usernameInput.value = '';
        passwordInput.value = '';
    }

    /**
     * Handles user login or signup based on the current mode.
     * Stores user data in an in-memory 'users' object (not persistent).
     */
    async function authAction() {
        const username = usernameInput.value.trim();
        const password = passwordInput.value.trim();

        if (!username || !password) {
            await showCustomModal("Error", "Username and password cannot be empty.");
            return;
        }

        if (isLoginMode) {
            // Login existing user
            if (users[username] && users[username].password === password) {
                currentUser = {
                    id: users[username].id,
                    username: username,
                    lives: 3, // Default lives for game
                    elo: users[username].elo,
                    soloStage: users[username].soloStage,
                    rankedCorrectAnswers: users[username].rankedCorrectAnswers || 0,
                    rankedTotalAnswers: users[username].rankedTotalAnswers || 0,
                    casualCorrectAnswers: users[username].casualCorrectAnswers || 0,
                    casualTotalAnswers: users[username].casualTotalAnswers || 0,
                    casualPoints: users[username].casualPoints || 0,
                    tokens: users[username].tokens || 0,
                    inventory: users[username].inventory || [],
                    equippedTitle: users[username].equippedTitle || 'New Rival' // Default title
                };
                userId = currentUser.id; // Set userId for the session
                handleSuccessfulAuth();
            } else {
                await showCustomModal("Error", "Invalid username or password.");
            }
        } else {
            // Register new user
            if (users[username]) {
                await showCustomModal("Error", "Username already exists. Please choose a different one.");
                return;
            }
            const newId = `user_${nextUserId++}`;
            users[username] = {
                id: newId,
                password: password,
                soloStage: 0,
                rankedCorrectAnswers: 0,
                rankedTotalAnswers: 0,
                elo: 0, // Starting ELO for new users is 0
                casualCorrectAnswers: 0,
                casualTotalAnswers: 0,
                casualPoints: 0, // New users start with 0 casual points
                tokens: 0, // New users start with 0 tokens
                inventory: [], // New users start with empty inventory
                equippedTitle: 'New Rival' // Default title for new users
            };
            await showCustomModal("Success", `Account for "${username}" created! Please login.`);
            toggleAuthMode(); // Switch to login mode
            usernameInput.value = username;
            passwordInput.value = '';
        }
    }

    /**
     * Handles user logout. Clears current user session and resets UI.
     */
    async function logout() {
        const confirmed = await showCustomModal("Confirm Logout", "Are you sure you want to log out?", true);
        if (confirmed) {
            // Clean up any active lobby state if user is in one
            if (currentLobbyId && activeLobbies[currentLobbyId]) {
                const lobby = activeLobbies[currentLobbyId];
                lobby.players = lobby.players.filter(p => p.id !== currentUser.id);
                // If no human players left, remove the lobby entirely
                if (lobby.players.filter(p => p.type === 'human').length === 0) {
                    delete activeLobbies[currentLobbyId];
                }
            }

            currentUser = null;
            userId = null;
            if (timer) clearInterval(timer); // Stop any active game timer

            // Reset UI to initial login state
            showSection(authContainer);
            logoutBtn.style.display = 'none'; // Hide logout button
            profileIcon.style.display = 'none'; // Hide profile icon
            inventoryIcon.style.display = 'none'; // Hide inventory icon
            shopIcon.style.display = 'none'; // Hide shop icon
            codeInputIcon.style.display = 'none'; // Hide code input icon
            welcomeMessage.style.display = 'none';
            usernameInput.value = '';
            passwordInput.value = '';
            await showCustomModal("Logged Out", "You have been successfully logged out.");

            // Reset game-specific states
            players = [];
            currentLobbyType = '';
            currentLobbyId = '';
            isPlayerReady = false;
            isRankedMatch = false;
            isCustomMatch = false; // Reset custom flag
            currentQuestionIndex = 0;
            currentPlayerIndex = 0;
            timeLeft = 30;
            currentSoloStage = 0; // Reset this for the next login to ensure it loads from stored user data
            updateGlobalLeaderboard(); // Refresh global leaderboard (will show only bots if no humans logged in)
        }
    }

    /**
     * Updates the UI after successful login.
     */
    function handleSuccessfulAuth() {
        welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
        welcomeMessage.style.display = 'block';
        logoutBtn.style.display = 'block'; // Ensure logout button is shown here
        profileIcon.style.display = 'flex'; // Ensure profile icon is shown here
        inventoryIcon.style.display = 'flex'; // Ensure inventory icon is shown here
        shopIcon.style.display = 'flex'; // Ensure shop icon is shown here
        codeInputIcon.style.display = 'flex'; // Ensure code input icon is shown here
        showSection(mainLobbyDashboard); // Show main lobby dashboard after login
        updateGlobalLeaderboard(); // Update global leaderboard on login
    }

    /**
     * Sends updated user data to the backend. (Functionality removed for local-only version)
     * @param {Object} userData The user data to send.
     */
    async function sendUserDataToBackend(userData) {
        // This function is no longer active in the local-only version.
        // Data persistence will not occur across browser sessions.
        console.warn("sendUserDataToBackend: This function is disabled in local-only mode. User data will not persist.");
    }

    // --- Global Leaderboard (Uses in-memory 'users' data) ---
    /**
     * Updates the global leaderboard table using the in-memory 'users' data.
     */
    function updateGlobalLeaderboard() {
        globalLeaderboardBody.innerHTML = '';

        let globalPlayers = [];
        // Iterate through the in-memory users object
        for (const username in users) {
            const userData = users[username];
            globalPlayers.push({
                username: username,
                elo: userData.elo || 0,
                rankedCorrectAnswers: userData.rankedCorrectAnswers || 0,
                rankedTotalAnswers: userData.rankedTotalAnswers || 0
            });
        }

        // Sort by ELO (descending)
        globalPlayers.sort((a, b) => b.elo - a.elo);

        if (globalPlayers.length === 0) {
            const row = globalLeaderboardBody.insertRow();
            const cell = row.insertCell(0);
            cell.colSpan = 4;
            cell.textContent = 'No leaderboard data available.';
            cell.style.textAlign = 'center';
            return;
        }

        globalPlayers.forEach((player, index) => {
            const row = globalLeaderboardBody.insertRow();
            const accuracy = player.rankedTotalAnswers > 0 ? ((player.rankedCorrectAnswers / player.rankedTotalAnswers) * 100).toFixed(0) : 0;
            row.innerHTML = `
                <td>${index + 1}</td>
                <td>${player.username}</td>
                <td>${player.elo}</td>
                <td>${accuracy}%</td>
            `;
        });
    }

    // --- Lobby Management Functions (In-Memory) ---

    /**
     * Generates a simple unique lobby ID.
     * @param {string} prefix A prefix for the lobby ID.
     * @returns {string} A unique lobby ID.
     */
    function generateLobbyId(prefix) {
        return `${prefix}-${Math.random().toString(36).substring(2, 8)}`;
    }

    /**
     * Opens the modal to create a new lobby.
     */
    function createNewLobby() {
        if (!currentUser) {
            showCustomModal("Error", "You must be logged in to create a lobby.");
            return;
        }
        createLobbyModal.style.display = 'flex';
        newLobbyNameInput.value = ''; // Clear previous input
        frenzyModeToggle.checked = false; // Default frenzy mode off

        // Dynamically populate max players options based on currentLobbyType
        newLobbyMaxPlayersSelect.innerHTML = ''; // Clear existing options
        if (currentLobbyType.includes('1v1')) { // Works for casual and custom 1v1
            const option = document.createElement('option');
            option.value = '2';
            option.textContent = '2 Players';
            newLobbyMaxPlayersSelect.appendChild(option);
            newLobbyMaxPlayersSelect.value = '2'; // Ensure it's selected
            newLobbyMaxPlayersSelect.disabled = true; // Disable selection for 1v1
        } else { // Default options for other game types (e.g., 4v4 Q&A, Custom 4v4)
            const options = [2, 3, 4];
            options.forEach(num => {
                const option = document.createElement('option');
                option.value = num;
                option.textContent = `${num} Players`;
                newLobbyMaxPlayersSelect.appendChild(option);
            });
            newLobbyMaxPlayersSelect.value = '2'; // Default to 2 players for other modes
            newLobbyMaxPlayersSelect.disabled = false; // Enable selection
        }
        // Set default values for new options
        initialLivesSelect.value = '3';
        questionTimerSelect.value = '30';

        // Hide custom mode options if not creating a custom lobby
        const isCustomLobbyCreation = currentLobbyType.startsWith('custom-');
        document.querySelector('label[for="initial-lives-select"]').style.display = isCustomLobbyCreation ? 'block' : 'none';
        initialLivesSelect.style.display = isCustomLobbyCreation ? 'block' : 'none';
        document.querySelector('label[for="question-timer-select"]').style.display = isCustomLobbyCreation ? 'block' : 'none';
        questionTimerSelect.style.display = isCustomLobbyCreation ? 'block' : 'none';
        document.querySelector('.checkbox-container').style.display = isCustomLobbyCreation ? 'block' : 'none';
    }

    /**
     * Closes the create lobby modal.
     */
    function closeCreateLobbyModal() {
        createLobbyModal.style.display = 'none';
        newLobbyNameInput.value = '';
        frenzyModeToggle.checked = false;
        initialLivesSelect.value = '3';
        questionTimerSelect.value = '30';
        // Reset max players select to default state (e.g., re-enable and show all options)
        newLobbyMaxPlayersSelect.innerHTML = `
            <option value="2">2 Players</option>
            <option value="3">3 Players</option>
            <option value="4">4 Players</option>
        `;
        newLobbyMaxPlayersSelect.value = '2';
        newLobbyMaxPlayersSelect.disabled = false;
    }

    /**
     * Confirms and creates a new lobby based on modal inputs.
     */
    async function confirmCreateLobby() {
        const lobbyName = newLobbyNameInput.value.trim();
        const maxPlayers = parseInt(newLobbyMaxPlayersSelect.value);
        const isFrenzyMode = frenzyModeToggle.checked; // Get frenzy mode state
        const initialLives = parseInt(initialLivesSelect.value); // Get initial lives
        const questionTimerValue = parseInt(questionTimerSelect.value); // Get question timer

        if (!lobbyName) {
            await showCustomModal("Error", "Please enter a lobby name.");
            return;
        }

        const newLobbyId = generateLobbyId(currentLobbyType.replace('-', '_'));

        const initialPlayer = {
            id: currentUser.id,
            name: currentUser.username,
            isReady: false, // For casual lobbies, still require manual ready-up
            type: 'human',
            elo: currentUser.elo,
            casualPoints: currentUser.casualPoints, // Include casual points
            rankedCorrectAnswers: currentUser.rankedCorrectAnswers,
            rankedTotalAnswers: currentUser.rankedTotalAnswers,
            casualCorrectAnswers: currentUser.casualCorrectAnswers,
            casualTotalAnswers: currentUser.casualTotalAnswers,
            lives: initialLives, // Set initial lives from lobby setting
            cards: [], // Initialize cards array for custom mode
            shields: 0, // Initialize shields for custom mode
            goldenDefenseUsed: false // Track Golden Defense usage
        };

        const newLobby = {
            id: newLobbyId,
            name: lobbyName,
            type: currentLobbyType,
            players: [initialPlayer],
            maxPlayers: maxPlayers,
            gameStarted: false,
            chatMessages: [],
            // Track if it's a ranked lobby
            isRanked: currentLobbyType.startsWith('ranked-'),
            isCustom: currentLobbyType.startsWith('custom-'), // New: Track if it's a custom lobby
            isFrenzyMode: isFrenzyMode, // New: Store frenzy mode setting
            initialLives: initialLives, // New: Store initial lives setting
            questionTimer: questionTimerValue, // New: Store question timer setting
            playerCycles: 0 // New: Track player turns for card distribution
        };

        // Add bots if maxPlayers > 1 for simulation purposes
        for (let i = 1; i < maxPlayers; i++) {
            newLobby.players.push({
                id: `bot_${newLobbyId}_${i}`,
                name: `Bot_${i}`,
                isReady: true, // Bots are always ready
                type: 'bot',
                elo: 0, // Bots start with 0 ELO
                casualPoints: 0, // Bots start with 0 casual points
                rankedCorrectAnswers: 0,
                rankedTotalAnswers: 0,
                casualCorrectAnswers: 0,
                casualTotalAnswers: 0,
                lives: initialLives, // Bots also get initial lives from lobby setting
                cards: [], // Initialize cards array for custom mode
                shields: 0, // Initialize shields for custom mode
                goldenDefenseUsed: false // Track Golden Defense usage
            });
        }

        activeLobbies[newLobbyId] = newLobby;
        closeCreateLobbyModal();
        await joinLobby(newLobbyId); // Automatically join the newly created lobby
    }

    /**
     * Displays the list of available lobbies for a given game type.
     * This function is now primarily for casual and custom lobbies.
     * @param {string} type The game mode type ('free-for-all-qna', '1v1-fill-in-blanks', 'custom-qna', 'custom-fill-in-blanks').
     */
    function showLobbyList(type) {
        if (!currentUser) {
            showCustomModal("Error", "Please log in to view lobbies.");
            return;
        }

        currentLobbyType = type; // Set the current lobby type
        isRankedMatch = false; // Not a ranked match
        isCustomMatch = type.startsWith('custom-'); // Set custom flag

        showSection(lobbyListContainer);
        if (type === 'free-for-all-qna') {
            lobbyListTitle.textContent = 'Available Free for All Q&A Lobbies';
        } else if (type === '1v1-fill-in-blanks') {
            lobbyListTitle.textContent = 'Available 1v1 Fill in the Blanks Lobbies';
        } else if (type === 'custom-qna') {
            lobbyListTitle.textContent = 'Available Custom Q&A Lobbies';
        } else if (type === 'custom-fill-in-blanks') {
            lobbyListTitle.textContent = 'Available Custom 1v1 Fill in the Blanks Lobbies';
        }
        renderLobbies();
    }

    /**
     * Initiates a ranked match by finding or creating a hidden lobby for the specified game type.
     * @param {string} gameType The specific ranked game type (e.g., 'ranked-free-for-all-qna', 'ranked-1v1-fill-in-blanks').
     */
    async function initiateRankedMatch(gameType) {
        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to join a ranked lobby.");
            return;
        }

        currentLobbyType = gameType; // Set the current lobby type to the ranked game type
        isRankedMatch = true; // This is a ranked match
        isCustomMatch = false; // Not a custom match

        let foundLobby = null;
        // Try to find an existing ranked lobby that is not full and not started
        for (const lobbyId in activeLobbies) {
            const lobby = activeLobbies[lobbyId];
            if (lobby.type === gameType && lobby.players.length < lobby.maxPlayers && !lobby.gameStarted) {
                foundLobby = lobby;
                break;
            }
        }

        if (foundLobby) {
            await joinLobby(foundLobby.id);
        } else {
            // No suitable lobby found, create a new one
            const newLobbyId = generateLobbyId(gameType.replace(/-/g, '_')); // Use gameType for ID prefix
            let maxPlayers;
            let lobbyName;

            if (gameType === 'ranked-1v1-fill-in-blanks') {
                maxPlayers = 2;
                lobbyName = "Ranked 1v1 Match";
            } else if (gameType === 'ranked-free-for-all-qna') {
                maxPlayers = 4; // Assuming 4 players for ranked FFA
                lobbyName = "Ranked FFA Match";
            } else {
                console.error("Unknown ranked game type:", gameType);
                await showCustomModal("Error", "Invalid ranked game type selected.");
                return;
            }

            const initialPlayer = {
                id: currentUser.id,
                name: currentUser.username,
                isReady: true, // Auto ready-up for ranked lobbies
                type: 'human',
                elo: currentUser.elo,
                casualPoints: currentUser.casualPoints,
                rankedCorrectAnswers: currentUser.rankedCorrectAnswers,
                rankedTotalAnswers: currentUser.rankedTotalAnswers,
                casualCorrectAnswers: currentUser.casualCorrectAnswers,
                casualTotalAnswers: currentUser.casualTotalAnswers,
                lives: 3, // Default lives for ranked
                cards: [], // No cards in ranked
                shields: 0,
                goldenDefenseUsed: false
            };

            const newLobby = {
                id: newLobbyId,
                name: lobbyName,
                type: gameType, // Store the specific ranked game type
                players: [initialPlayer],
                maxPlayers: maxPlayers,
                gameStarted: false,
                chatMessages: [],
                isRanked: true, // Mark as ranked
                isCustom: false,
                isFrenzyMode: false, // No frenzy mode in ranked
                initialLives: 3,
                questionTimer: 30, // Default timer for ranked
                playerCycles: 0
            };

            // Add bots to fill the lobby
            for (let i = 1; i < maxPlayers; i++) {
                newLobby.players.push({
                    id: `bot_${newLobbyId}_${i}`,
                    name: `RankedBot_${i}`,
                    isReady: true,
                    type: 'bot',
                    elo: 0, // Bots start with 0 ELO
                    casualPoints: 0, // Bots start with 0 casual points
                    rankedCorrectAnswers: 0,
                    rankedTotalAnswers: 0,
                    casualCorrectAnswers: 0,
                    casualTotalAnswers: 0,
                    lives: 3,
                    cards: [],
                    shields: 0,
                    goldenDefenseUsed: false
                });
            }

            activeLobbies[newLobbyId] = newLobby;
            await joinLobby(newLobbyId);
        }
    }


    /**
     * Renders the list of lobbies in the lobbies grid.
     */
    function renderLobbies() {
        lobbiesGrid.innerHTML = ''; // Clear existing lobbies

        // Only display lobbies that match the currentLobbyType and are not ranked
        const lobbiesToDisplay = Object.values(activeLobbies).filter(lobby =>
            lobby.type === currentLobbyType && !lobby.isRanked
        );

        if (lobbiesToDisplay.length === 0) {
            lobbiesGrid.innerHTML = '<p style="color: #ccc; text-align: center;">No lobbies found. Create one!</p>';
            return;
        }

        lobbiesToDisplay.forEach((lobby) => {
            const playerCount = lobby.players ? lobby.players.length : 0;
            const maxPlayers = lobby.maxPlayers;
            const isFull = playerCount >= maxPlayers;

            const lobbyCard = document.createElement('div');
            lobbyCard.className = `lobby-card ${isFull || lobby.gameStarted ? 'full' : ''}`;
            lobbyCard.innerHTML = `
                <h3>${lobby.name} <span style="font-size: 0.8em; opacity: 0.7;">(ID: ${lobby.id})</span></h3>
                <p>Players: ${playerCount}/${maxPlayers}</p>
                <p>Status: ${lobby.gameStarted ? 'In Game' : 'Waiting'}</p>
                <p>Mode: ${lobby.isCustom ? 'Custom' : 'Casual'}</p>
                ${lobby.isCustom ? `<p>Frenzy Mode: ${lobby.isFrenzyMode ? 'On' : 'Off'}</p>` : ''}
                <button class="join-btn primary-btn" data-lobby-id="${lobby.id}" ${isFull || lobby.gameStarted ? 'disabled' : ''}>
                    ${isFull ? 'Full' : (lobby.gameStarted ? 'In Game' : 'Join')}
                </button>
            `;
            lobbyCard.querySelector('.join-btn').addEventListener('click', () => joinLobby(lobby.id));
            lobbiesGrid.appendChild(lobbyCard);
        });
    }

    /**
     * Joins an existing lobby.
     * @param {string} lobbyIdToJoin The ID of the lobby to join.
     */
    async function joinLobby(lobbyIdToJoin) {
        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to join a lobby.");
            return;
        }

        const lobby = activeLobbies[lobbyIdToJoin];
        if (!lobby) {
            await showCustomModal("Error", "Lobby does not exist.");
            return;
        }

        currentLobbyId = lobbyIdToJoin;
        isRankedMatch = lobby.isRanked; // Set ranked flag based on lobby property
        isCustomMatch = lobby.isCustom; // Set custom flag based on lobby property
        let currentPlayers = lobby.players || [];

        // Check if player is already in this lobby
        if (currentPlayers.some(p => p.id === currentUser.id)) {
            // Player is already in this lobby, just re-enter view
        } else {
            // If lobby is full, prevent joining
            if (currentPlayers.length >= lobby.maxPlayers) {
                await showCustomModal("Error", "Lobby is full.");
                currentLobbyId = ''; // Clear lobby id if cannot join
                return;
            }

            // Add current user to the lobby
            const playerToAdd = {
                id: currentUser.id,
                name: currentUser.username,
                isReady: lobby.isRanked ? true : false, // Auto ready for ranked, manual for casual/custom
                type: 'human',
                elo: currentUser.elo,
                casualPoints: currentUser.casualPoints,
                rankedCorrectAnswers: currentUser.rankedCorrectAnswers,
                rankedTotalAnswers: currentUser.rankedTotalAnswers,
                casualCorrectAnswers: currentUser.casualCorrectAnswers,
                casualTotalAnswers: currentUser.casualTotalAnswers,
                lives: lobby.initialLives, // Get initial lives from lobby setting
                cards: [], // Initialize cards array for custom mode
                shields: 0, // Initialize shields for custom mode
                goldenDefenseUsed: false // Track Golden Defense usage
            };
            currentPlayers.push(playerToAdd);
            lobby.players = currentPlayers; // Update in-memory lobby
        }

        // Update local players array from the lobby
        players = [...lobby.players];
        const currentPlayerInLobby = players.find(p => p.id === currentUser.id);
        isPlayerReady = currentPlayerInLobby ? currentPlayerInLobby.isReady : false;

        showSection(singleLobbyView);
        currentLobbyTitle.textContent = `Lobby: ${lobby.name}`;
        displayLobbyId.textContent = currentLobbyId;
        displayPlayerCount.textContent = players.length;
        displayMaxPlayers.textContent = lobby.maxPlayers;
        displayLobbyStatus.textContent = lobby.gameStarted ? 'In Game' : 'Waiting';

        updateReadyButtonState();
        renderLobbyPlayers();
        updateStartGameButtonState();

        // Ensure correct chatbox is visible based on the lobby type
        if (currentLobbyType.includes('qna')) { // Works for casual, ranked, and custom FFA Q&A
            chatBox4v4.style.display = 'flex';
            renderChatMessages('4v4', lobby.chatMessages);
        } else if (currentLobbyType.includes('fill-in-blanks')) { // Works for casual, ranked, and custom 1v1 fill-in-the-blanks
            chatBox1v1.style.display = 'flex';
            renderChatMessages('1v1', lobby.chatMessages);
        }
    }

    /**
     * Leaves the current lobby.
     */
    async function leaveLobby() {
        if (!currentLobbyId || !currentUser) {
            return; // Not in a lobby
        }

        const confirmed = await showCustomModal("Confirm Leave", "Are you sure you want to leave this lobby?", true);
        if (!confirmed) {
            return;
        }

        const lobby = activeLobbies[currentLobbyId];
        if (lobby) {
            lobby.players = lobby.players.filter(p => p.id !== currentUser.id);
            // If no human players left, remove the lobby entirely
            if (lobby.players.filter(p => p.type === 'human').length === 0) {
                delete activeLobbies[currentLobbyId];
            }
        }
        leaveLobbyStateCleanUp();
        await showCustomModal("Lobby Left", "You have left the lobby.");
    }

    /**
     * Cleans up state after leaving a lobby.
     */
    function leaveLobbyStateCleanUp() {
        currentLobbyId = '';
        players = [];
        isPlayerReady = false;
        isRankedMatch = false; // Reset ranked flag
        isCustomMatch = false; // Reset custom flag
        // If leaving a ranked lobby, go back to ranked game mode selection
        if (currentLobbyType.startsWith('ranked-')) {
            showSection(rankedGameModeSelection);
        } else {
            showSection(lobbyListContainer); // Go back to the list of lobbies for the current type
            renderLobbies(); // Re-render lobbies to reflect changes
        }
        currentLobbyType = ''; // Clear lobby type after leaving
    }

    /**
     * Toggles the current user's ready status in the lobby.
     */
    function toggleReady() {
        if (!currentLobbyId || !currentUser) {
            showCustomModal("Error", "Not in a lobby.");
            return;
        }

        const lobby = activeLobbies[currentLobbyId];
        if (lobby) {
            const playerIndex = lobby.players.findIndex(p => p.id === currentUser.id);
            if (playerIndex !== -1) {
                lobby.players[playerIndex].isReady = !lobby.players[playerIndex].isReady;
                isPlayerReady = lobby.players[playerIndex].isReady; // Update local state
                players = [...lobby.players]; // Update local players array
                updateReadyButtonState();
                renderLobbyPlayers(); // Re-render players to reflect ready status
                updateStartGameButtonState(); // Update start button based on new ready status
            }
        }
    }

    /**
     * Updates the text and styling of the "Ready Up!" button.
     */
    function updateReadyButtonState() {
        readyToggleBtn.textContent = isPlayerReady ? 'Unready' : 'Ready Up!';
        readyToggleBtn.style.backgroundColor = isPlayerReady ? '#e08000' : '#008000'; // Orange for unready, Green for ready
        readyToggleBtn.style.borderColor = isPlayerReady ? '#ff9900' : '#00ff00';
        readyToggleBtn.style.boxShadow = isPlayerReady ? '0 0 10px #ff9900' : '0 0 10px #00ff00';
        // Disable ready button if in a ranked lobby (since it's auto-ready)
        readyToggleBtn.disabled = isRankedMatch;
    }

    /**
     * Renders the list of players within the single lobby view.
     */
    function renderLobbyPlayers() {
        lobbyPlayersDisplay.innerHTML = ''; // Clear current players

        players.forEach(p => {
            const playerCard = document.createElement('div');
            playerCard.className = 'lobby-card'; // Reuse lobby card style for players
            playerCard.style.cursor = 'default';
            playerCard.style.minHeight = 'auto';
            playerCard.style.padding = '15px';

            playerCard.innerHTML = `
                <h3>${p.name} ${p.id === currentUser.id ? "(You)" : ""} ${p.type === 'bot' ? "(Bot)" : ""}</h3>
                <p>${isRankedMatch ? 'ELO' : 'Points'}: ${isRankedMatch ? p.elo : p.casualPoints}</p>
                <p>Lives: ${p.lives}</p>
                <p>Status: <span class="player-status ${p.isReady ? 'ready' : 'not-ready'}">${p.isReady ? 'Ready' : 'Not Ready'}</span></p>
            `;
            lobbyPlayersDisplay.appendChild(playerCard);
        });
    }

    /**
     * Updates the enabled/disabled state of the "Start Game" button.
     */
    function updateStartGameButtonState() {
        const lobby = activeLobbies[currentLobbyId];

        if (!lobby) {
            startGameButton.disabled = true;
            return;
        }

        // Only the first player (host) can start the game in this basic implementation
        const isHost = lobby.players[0] && lobby.players[0].id === currentUser.id;
        const allPlayersReady = lobby.players.length > 0 && lobby.players.every(p => p.isReady);
        const hasMinPlayers = lobby.players.length >= 2; // Example: require at least 2 players

        startGameButton.disabled = !(isHost && allPlayersReady && hasMinPlayers);

        if (isHost && allPlayersReady && hasMinPlayers) {
            startGameButton.title = "All players are ready! Click to start.";
        } else if (isHost) {
            let tooltip = "You are the host. ";
            if (!hasMinPlayers) tooltip += "Need at least 2 players. ";
            if (!allPlayersReady) tooltip += "Waiting for all players to be ready.";
            startGameButton.title = tooltip;
        } else {
            startGameButton.title = "Only the host can start the game when all players are ready.";
        }
    }

    /**
     * Initiates the game for the current lobby.
     */
    async function startGame() {
        if (!currentLobbyId || !currentUser) {
            showCustomModal("Error", "Not in a lobby.");
            return;
        }

        const confirmed = await showCustomModal("Confirm Game Start", "Are you sure you want to start the game?", true);
        if (!confirmed) {
            return;
        }

        const lobby = activeLobbies[currentLobbyId];
        if (!lobby) {
            showCustomModal("Error", "Lobby not found to start game.");
            return;
        }

        // Basic host check (first player in the lobby)
        const isHost = lobby.players[0] && lobby.players[0].id === currentUser.id;
        if (!isHost) {
            showCustomModal("Permission Denied", "Only the lobby host can start the game.");
            return;
        }

        // Check if all players are ready and there are enough players
        const allPlayersReady = lobby.players.length > 0 && lobby.players.every(p => p.isReady);
        const hasMinPlayers = lobby.players.length >= 2;

        if (!hasMinPlayers) {
            showCustomModal("Cannot Start", "Need at least 2 players to start the game.");
            return;
        }

        if (!allPlayersReady) {
            showCustomModal("Cannot Start", "Not all players are ready.");
            return;
            }

        lobby.gameStarted = true;
        await showCustomModal("Game Started!", "The game is commencing!");
        startGameUI(lobby.type); // Transition to game UI
    }

    /**
     * Transitions the UI to the game screen based on game type.
     * @param {string} gameType The type of game to start ('free-for-all-qna', '1v1-fill-in-blanks', 'ranked-1v1-fill-in-blanks', 'ranked-free-for-all-qna', 'custom-qna', 'custom-fill-in-blanks').
     */
    function startGameUI(gameType) {
        showSection(gameUI); // Show common game UI wrapper
        mainContentWrapper.style.display = 'flex'; // Ensure wrapper is visible

        // Hide all specific game layouts initially
        fourVFourQnALayout.style.display = 'none';
        oneVOneFillInBlanksLayout.style.display = 'none';

        if (gameType.includes('qna')) { // Works for all Q&A types
            fourVFourQnALayout.style.display = 'flex';
            chatBox4v4.style.display = 'flex'; // Explicitly show 4v4 chat
            playerCardsContainer4v4.style.display = 'flex'; // Show card container
            initializeGameRound(gameType);
        } else if (gameType.includes('fill-in-blanks')) { // Works for all Fill-in-the-blanks types
            oneVOneFillInBlanksLayout.style.display = 'flex';
            chatBox1v1.style.display = 'flex'; // Explicitly show 1v1 chat
            playerCardsContainer1v1.style.display = 'flex'; // Show card container
            initializeGameRound(gameType);
        }
    }

    /**
     * Leaves the current game and returns to the single lobby view.
     * @param {boolean} gameWon Indicates if the current user won the game.
     */
    async function leaveGame(gameWon = false) {
        const confirmed = await showCustomModal("Confirm Exit Game", "Are you sure you want to exit the current game and return to lobbies?", true);
        if (!confirmed) {
            return;
        }
        if (timer) clearInterval(timer);

        // Award tokens before cleanup
        awardTokens(gameWon);

        // Reset game UI elements
        gameTimerDisplay.textContent = '30';
        answerInput4v4.value = '';
        answerInput4v4.disabled = false;
        submitAnswerBtn4v4.style.display = 'block';
        replayButton.style.display = 'none';
        playerCircleDiv.innerHTML = ''; // Clear players from 4v4 view
        questionBox1v1Player1.style.display = 'none';
        questionBox1v1Player2.style.display = 'none';
        playerCardsContainer4v4.innerHTML = ''; // Clear cards
        playerCardsContainer1v1.innerHTML = ''; // Clear cards


        const lobby = activeLobbies[currentLobbyId];
        if (lobby) {
            lobby.gameStarted = false; // Reset game started flag
            lobby.playerCycles = 0; // Reset player cycles for next game

            // Reset player states for the lobby view
            lobby.players = lobby.players.map(p => ({
                ...p,
                lives: lobby.initialLives, // Reset lives to lobby's initial setting
                currentRoundScore: 0,
                roundCorrectAnswers: 0,
                roundTotalAnswers: 0,
                isReady: p.type === 'human' ? (lobby.isRanked ? true : false) : true, // Human ready state depends on lobby type, bots stay ready
                cards: [], // Clear cards on leaving game
                shields: 0, // Clear shields
                goldenDefenseUsed: false // Reset golden defense usage
            }));
            players = [...lobby.players]; // Update local players array

            // Update current user's ready status in the lobby
            const currentPlayerInLobby = players.find(p => p.id === currentUser.id);
            isPlayerReady = currentPlayerInLobby ? currentPlayerInLobby.isReady : false;

            showSection(singleLobbyView); // Go back to single lobby view
            currentLobbyTitle.textContent = `Lobby: ${lobby.name}`;
            displayLobbyId.textContent = currentLobbyId;
            displayPlayerCount.textContent = players.length;
            displayMaxPlayers.textContent = lobby.maxPlayers;
            displayLobbyStatus.textContent = lobby.gameStarted ? 'In Game' : 'Waiting';

            updateReadyButtonState();
            renderLobbyPlayers();
            updateStartGameButtonState();
            // Re-render chat for the specific lobby
            if (lobby.type.includes('qna')) {
                chatBox4v4.style.display = 'flex';
                renderChatMessages('4v4', lobby.chatMessages);
            } else if (lobby.type.includes('fill-in-blanks')) {
                chatBox1v1.style.display = 'flex';
                renderChatMessages('1v1', lobby.chatMessages);
            }
        } else {
            // If lobby no longer exists (e.g., deleted due to no human players)
            leaveLobbyStateCleanUp(); // Go back to lobby list
            showCustomModal("Lobby Ended", "The lobby has ended. Returning to lobby list.");
        }
    }

    /**
     * Leaves the solo challenge and returns to the game mode selection.
     */
    async function leaveSoloChallenge() {
        const confirmed = await showCustomModal("Confirm Exit Solo Challenge", "Are you sure you want to exit the solo challenge and return to mode selection?", true);
        if (!confirmed) {
            return;
        }
        showSection(gameModeSelection);
        // Save current solo stage to in-memory user data
        if (currentUser) {
            users[currentUser.username].soloStage = currentUser.soloStage;
        }
        currentSoloStage = currentUser ? currentUser.soloStage : 0; // Reset solo stage to last saved
    }

    /**
     * Returns from lobby list to game mode selection (casual or ranked).
     */
    function backToModeSelection() {
        // Determine which mode selection to go back to based on currentLobbyType
        if (currentLobbyType.startsWith('ranked-')) {
            showSection(rankedGameModeSelection);
        } else {
            showSection(gameModeSelection);
        }
        currentLobbyId = '';
        currentLobbyType = ''; // Clear currentLobbyType
        isRankedMatch = false; // Reset ranked flag
        isCustomMatch = false; // Reset custom flag
        players = [];
        isPlayerReady = false;
    }

    /**
     * Returns from single lobby view to the lobby list.
     */
    function backToLobbiesList() {
        showSection(lobbyListContainer);
        currentLobbyId = '';
        isPlayerReady = false; // Reset ready status
        updateReadyButtonState(); // Reset button text
        renderLobbies(); // Refresh lobby list
    }

    /**
     * Returns from game mode selection (casual or ranked) or inventory/shop or profile to the main lobby dashboard.
     */
    function backToDashboard() {
        showSection(mainLobbyDashboard);
        currentLobbyType = ''; // Clear current lobby type
        isRankedMatch = false; // Reset ranked flag
        isCustomMatch = false; // Reset custom flag
        // Update welcome message to reflect latest ELO and tokens
        if (currentUser) {
            welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
        }
    }

    // --- In-Game Functions (Q&A / Fill-in-the-blanks) ---

    /**
     * Initializes a new game round for multiplayer modes.
     * @param {string} gameType The type of game to start ('free-for-all-qna', '1v1-fill-in-blanks', 'ranked-1v1-fill-in-blanks', 'ranked-free-for-all-qna', 'custom-qna', 'custom-fill-in-blanks').
     */
    function initializeGameRound(gameType) {
        const lobby = activeLobbies[currentLobbyId];
        if (!lobby) {
            console.error("Lobby not found during game round initialization.");
            return;
        }

        // Determine which set of questions to use based on the gameType
        if (gameType.includes('qna')) {
            questions = [...originalQuestions];
        } else if (gameType.includes('fill-in-blanks')) {
            questions = [...fillInBlanksQuestions];
        } else {
            console.error("Unknown game type for question selection:", gameType);
            questions = [...originalQuestions]; // Default to original questions
        }
        questions.sort(() => Math.random() - 0.5); // Shuffle questions

        // Reset player lives and scores for the game round from the lobby's players
        players = lobby.players.map(p => ({
            ...p,
            lives: lobby.initialLives, // Use lobby's initial lives
            currentRoundScore: 0,
            roundCorrectAnswers: 0,
            roundTotalAnswers: 0,
            cards: [], // Clear cards initially, then distribute if frenzy
            shields: 0, // Reset shields for new game
            goldenDefenseUsed: false // Reset golden defense usage
        }));

        // Distribute initial cards if Frenzy Mode is enabled
        if (lobby.isFrenzyMode) {
            players.forEach(p => {
                distributeInitialCards(p, 3); // Give each player 3 cards at start
            });
        }

        playerCycles = 0; // Reset player cycles for card distribution
        currentQuestionIndex = 0;
        currentPlayerIndex = 0; // Start with the first player in the shuffled list
        updateGameUI();
        startTimer();

        // Focus the correct answer input based on game type and current player
        if (gameType.includes('qna')) { // Works for all Q&A types
            answerInput4v4.value = '';
            answerInput4v4.focus();
        } else if (gameType.includes('fill-in-blanks')) { // Works for all Fill-in-the-blanks types
            const currentPlayer = players.find(p => p.id === currentUser.id);
            if (currentPlayer && currentPlayer.id === players[currentPlayerIndex].id) { // If it's the current user's turn
                answerInput1v1Player1.value = '';
                answerInput1v1Player1.focus();
            } else {
                answerInput1v1Player1.value = '';
                answerInput1v1Player1.disabled = true; // Disable player's input if it's bot's turn
            }
        }
    }

    /**
     * Updates the game UI elements based on the current game state.
     */
    function updateGameUI() {
        // Hide all specific question boxes initially
        questionBox4v4.style.display = 'none';
        questionBox1v1Player1.style.display = 'none';
        questionBox1v1Player2.style.display = 'none';

        const currentPlayer = players[currentPlayerIndex];
        const lobby = activeLobbies[currentLobbyId];

        if (currentLobbyType.includes('qna')) { // Works for all Q&A types
            questionBox4v4.style.display = 'block';
            question4v4Display.textContent = questions[currentQuestionIndex].q;
            updatePlayerPositions4v4(); // For 4v4, update circular positions
            answerInput4v4.disabled = false;
            submitAnswerBtn4v4.style.display = 'block';
            renderPlayerCards(playerCardsContainer4v4); // Render cards for 4v4
        } else if (currentLobbyType.includes('fill-in-blanks')) { // Works for all Fill-in-the-blanks types
            render1v1Players(); // For 1v1, update side-by-side player panels
            renderPlayerCards(playerCardsContainer1v1); // Render cards for 1v1

            if (currentPlayer.id === currentUser.id) { // If it's the current user's turn
                player1Panel.classList.add('active-player-turn'); // Highlight current player's panel
                questionBox1v1Player1.style.display = 'block';
                question1v1Player1.textContent = questions[currentQuestionIndex].q;
                answerInput1v1Player1.disabled = false;
                answerInput1v1Player1.focus();
                submitAnswerBtn1v1Player1.style.display = 'block';
            } else { // If it's the bot's turn
                player2Panel.classList.add('active-player-turn'); // Highlight bot's panel
                questionBox1v1Player2.style.display = 'block';
                question1v1Player2.textContent = questions[currentQuestionIndex].q;
                answerInput1v1Player1.disabled = true; // Disable human player input
                submitAnswerBtn1v1Player1.style.display = 'none';
                handleBotAnswer(); // Trigger bot's turn
            }
        }

        // Apply Evolved Meta Vision hint if active for current player
        if (lobby.isFrenzyMode && currentPlayer.id === currentUser.id && currentPlayer.hasEvolvedMetaVision) {
            const currentQuestion = questions[currentQuestionIndex];
            const hint = currentQuestion.hint || currentQuestion.a.charAt(0) + '...'; // Provide first letter or generic hint
            showCustomModal("Evolved Meta Vision Hint", `Clue: "${hint}"`);
            currentPlayer.hasEvolvedMetaVision = false; // Consume the effect
            renderPlayerCards(currentLobbyType.includes('qna') ? playerCardsContainer4v4 : playerCardsContainer1v1); // Re-render cards to reflect consumed effect
        }

        updateLeaderboard(); // Update current round leaderboard
    }

    /**
     * Starts the countdown timer for the current question.
     */
    function startTimer() {
        if (timer) clearInterval(timer);
        const lobby = activeLobbies[currentLobbyId];
        timeLeft = lobby ? lobby.questionTimer : 30; // Use lobby's timer setting
        gameTimerDisplay.textContent = timeLeft;
        timer = setInterval(() => {
            timeLeft--;
            gameTimerDisplay.textContent = timeLeft;
            if (timeLeft <= 0) {
                clearInterval(timer);
                showCustomModal('Time Up!', `${players[currentPlayerIndex].name} ran out of time!`);
                processAnswer(false); // Time's up, process as wrong answer
            }
        }, 1000);
    }

    /**
     * Handles the submission of an answer by the user.
     */
    function submitAnswer() {
        clearInterval(timer); // Stop timer immediately

        let answerInput;
        let correctAnswer;

        if (currentLobbyType.includes('qna')) { // Works for all Q&A types
            answerInput = answerInput4v4;
            correctAnswer = questions[currentQuestionIndex].a;
            answerInput4v4.disabled = true;
            submitAnswerBtn4v4.style.display = 'none';
        } else if (currentLobbyType.includes('fill-in-blanks')) { // Works for all Fill-in-the-blanks types
            const currentPlayer = players[currentPlayerIndex];
            if (currentPlayer.id === currentUser.id) {
                answerInput = answerInput1v1Player1;
                correctAnswer = questions[currentQuestionIndex].a;
                answerInput1v1Player1.disabled = true;
                submitAnswerBtn1v1Player1.style.display = 'none';
            } else {
                showCustomModal("Error", "It's not your turn!");
                return;
            }
        }

        const userAnswer = answerInput.value.trim();
        const isCorrect = userAnswer.toLowerCase() === correctAnswer.toLowerCase();
        processAnswer(isCorrect);
        answerInput.value = ''; // Clear input for next question
    }

    let botChatInterval; // Interval for bot chat messages

    /**
     * Simulates a bot's answer for their turn.
     */
    async function handleBotAnswer() {
        const botSpeed = 3000; // Bot answers after 3 seconds
        if (timer) clearInterval(timer); // Pause human timer for bot turn
        gameTimerDisplay.textContent = "BOT THINKING...";

        // Stop previous bot chat interval if any
        if (botChatInterval) clearInterval(botChatInterval);

        // Start bot chat interval
        botChatInterval = setInterval(() => {
            const randomChat = [
                "Thinking...",
                "Analyzing the problem...",
                "This one's tricky!",
                "Almost got it...",
                "Compiling thoughts..."
            ][Math.floor(Math.random() * 5)];
            const lobby = activeLobbies[currentLobbyId];
            if (lobby) {
                const currentPlayer = players[currentPlayerIndex];
                lobby.chatMessages.push({
                    senderId: currentPlayer.id,
                    senderName: currentPlayer.name,
                    message: randomChat,
                    timestamp: new Date()
                });
                renderChatMessages(currentLobbyType.includes('qna') ? '4v4' : '1v1', lobby.chatMessages);
            }
        }, 3000); // Bot answers every 3 seconds

        setTimeout(() => {
            if (botChatInterval) clearInterval(botChatInterval); // Stop bot chat when answering
            let botIsCorrect = false;
            // Bots are not always accurate in multiplayer, but are in solo practice
            const accuracyRate = currentLobbyType.startsWith('solo-') ? BOT_ACCURACY_SOLO : BOT_ACCURACY_MULTIPLAYER;

            if (Math.random() < accuracyRate) {
                botIsCorrect = true;
            }
            processAnswer(botIsCorrect); // Bot answers (with a chance of being wrong)
        }, botSpeed);
    }


    /**
     * Processes an answer, updates player stats, and advances the game.
     * @param {boolean} isCorrect True if the answer was correct, false otherwise.
     */
    async function processAnswer(isCorrect) {
        if (timer) clearInterval(timer);
        if (botChatInterval) clearInterval(botChatInterval); // Stop bot chat interval if active

        const currentPlayer = players[currentPlayerIndex];
        const lobby = activeLobbies[currentLobbyId];

        // Update player's in-round stats
        currentPlayer.roundTotalAnswers++;

        let actualIsCorrect = isCorrect;

        // Check for Golden Defense shield
        if (!isCorrect && currentPlayer.shields > 0) {
            currentPlayer.shields--;
            actualIsCorrect = true; // Treat as correct for life deduction purposes
            await showCustomModal("Shield Block!", `${currentPlayer.name}'s Golden Defense absorbed the hit! Shields remaining: ${currentPlayer.shields}`);
        }

        if (actualIsCorrect) {
            currentPlayer.roundCorrectAnswers++;
            currentPlayer.currentRoundScore += timeLeft * 10; // Score based on remaining time
            await showCustomModal("Correct!", `Well done, ${currentPlayer.name}!`);
        } else {
            currentPlayer.lives--;
            currentPlayer.currentRoundScore -= 50; // Penalty for wrong answer
            await showCustomModal("Wrong!", `Incorrect. The answer was "${questions[currentQuestionIndex].a}". ${currentPlayer.name} loses a life.`);
        }

        // Update current user's ELO/Points and overall stats (in-memory 'users' object)
        if (currentPlayer.type === 'human' && currentPlayer.id === currentUser.id) {
            if (isRankedMatch) {
                currentUser.rankedTotalAnswers++;
                if (isCorrect) { // Only original correctness affects ranked stats
                    currentUser.rankedCorrectAnswers++;
                    currentUser.elo += 15; // More ELO for ranked correct answers
                } else {
                    currentUser.elo -= 10; // More ELO penalty for ranked incorrect answers
                }
                if (currentUser.elo < 0) currentUser.elo = 0; // Prevent negative ELO
                // Update the global in-memory users object
                users[currentUser.username].rankedCorrectAnswers = currentUser.rankedCorrectAnswers;
                users[currentUser.username].rankedTotalAnswers = currentUser.rankedTotalAnswers;
                users[currentUser.username].elo = currentUser.elo;
            } else { // Casual or Custom match, use points
                currentUser.casualTotalAnswers++;
                if (isCorrect) { // Only original correctness affects casual stats
                    currentUser.casualCorrectAnswers++;
                    currentUser.casualPoints += 10; // Points for casual correct answers
                } else {
                    currentUser.casualPoints -= 5; // Points penalty for casual incorrect answers
                }
                if (currentUser.casualPoints < 0) currentUser.casualPoints = 0; // Prevent negative points
                // Update the global in-memory users object
                users[currentUser.username].casualCorrectAnswers = currentUser.casualCorrectAnswers;
                users[currentUser.username].casualTotalAnswers = currentUser.casualTotalAnswers;
                users[currentUser.username].casualPoints = currentUser.casualPoints;
            }

            // Update the welcome message in the header to reflect new ELO/Points
            welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
        } else if (currentPlayer.type === 'bot') {
            // Update bot's ELO/Points (for display purposes, doesn't affect global leaderboard as bots aren't "users")
            // Bots' accuracy in multiplayer is not always accurate, but in solo practice it is.
            if (isRankedMatch) {
                if (isCorrect) {
                    currentPlayer.elo += 5;
                } else {
                    currentPlayer.elo = Math.max(0, currentPlayer.elo - 2);
                }
            } else { // Casual or Custom match, update bot's casual points
                if (isCorrect) {
                    currentPlayer.casualPoints += 5;
                } else {
                    currentPlayer.casualPoints = Math.max(0, currentPlayer.casualPoints - 2);
                }
            }
        }

        // Apply visual feedback
        if (currentLobbyType.includes('qna')) { // Works for all Q&A types
            const playerElement = document.querySelector(`.player[data-player-id="${currentPlayer.id}"] .name`);
            if (playerElement) {
                playerElement.classList.remove('active');
                playerElement.classList.add(isCorrect ? 'correct' : 'wrong');
                setTimeout(() => {
                    playerElement.classList.remove('correct', 'wrong');
                }, 1000); // Remove feedback after 1 second
            }
        } else if (currentLobbyType.includes('fill-in-blanks')) { // Works for all Fill-in-the-blanks types
            player1Panel.classList.remove('active-player-turn');
            player2Panel.classList.remove('active-player-turn');
        }

        // Check for game over or next round
        if (currentPlayer.lives <= 0) {
            await showCustomModal("Player Eliminated", `${currentPlayer.name} has been eliminated!`);
            players = players.filter(p => p.id !== currentPlayer.id);
            if (players.length <= 1) { // If only one or zero players remaining
                endGame();
                return;
            }
            // Adjust currentPlayerIndex if the current player was removed and it was the last one
            if (currentPlayerIndex >= players.length) {
                currentPlayerIndex = 0;
            }
        }

        // Increment playerCycles only if it was a human player's turn or a bot in multiplayer
        if (currentPlayer.type === 'human' || (currentPlayer.type === 'bot' && !currentLobbyType.startsWith('solo-'))) {
            lobby.playerCycles++;
            // Distribute new card every 2 cycles of players in Frenzy Mode
            if (lobby.isFrenzyMode && lobby.playerCycles % (players.length * 2) === 0) {
                distributeRandomCard();
            }
        }

        // Move to next player
        currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
        // Skip eliminated players
        while (players[currentPlayerIndex] && players[currentPlayerIndex].lives <= 0) {
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
        }

        // Move to next question after each answer
        currentQuestionIndex++;
        if (currentQuestionIndex >= questions.length) {
            currentQuestionIndex = 0; // Loop questions for continuous play in simulation
        }

        updateGameUI(); // Update UI for the next turn
        startTimer(); // Start timer for the next turn
        updateGlobalLeaderboard(); // Update global leaderboard after each answer for visibility
    }

    /**
     * Ends the current game round.
     */
    async function endGame() {
        if (timer) clearInterval(timer);
        if (botChatInterval) clearInterval(botChatInterval); // Stop bot chat interval if active

        await showCustomModal("Game Over!", "The game has ended. Check the leaderboard for results!");
        replayButton.style.display = 'block';
        // Hide all specific question boxes
        questionBox4v4.style.display = 'none';
        questionBox1v1Player1.style.display = 'none';
        questionBox1v1Player2.style.display = 'none';

        // Determine winner for token awarding
        let gameWinner = null;
        if (players.length === 1) {
            gameWinner = players[0];
        } else if (players.length > 1) {
            // In FFA, if multiple players remain, winner is the one with highest score
            // In 1v1, if both survive, winner is highest score
            const sortedByScore = [...players].sort((a,b) => b.currentRoundScore - a.currentRoundScore);
            gameWinner = sortedByScore[0];
        }

        const currentUserWon = gameWinner && gameWinner.id === currentUser.id;
        awardTokens(currentUserWon);
    }

    /**
     * Awards tokens to the current user based on game outcome and mode.
     * @param {boolean} wonGame True if the current user won the game.
     */
    async function awardTokens(wonGame) {
        let tokensEarned = 0;
        const baseTokens = 100; // Tokens for finishing a match
        const winBonusRanked = 150; // Additional tokens for winning a ranked match
        const winBonusCustom = 100; // Additional tokens for winning a custom match

        tokensEarned += baseTokens; // Always get base tokens for finishing

        if (wonGame) {
            if (isRankedMatch) {
                tokensEarned += winBonusRanked;
            } else if (isCustomMatch) {
                tokensEarned += winBonusCustom;
            }
        }

        // Halve tokens for casual mode (if not ranked or custom)
        if (!isRankedMatch && !isCustomMatch) {
            tokensEarned = Math.floor(tokensEarned / 2);
        }

        if (tokensEarned > 0) {
            currentUser.tokens += tokensEarned;
            users[currentUser.username].tokens = currentUser.tokens; // Update in-memory
            await showCustomModal("Tokens Earned!", `You earned ${tokensEarned} tokens! Total: ${currentUser.tokens}`);
            welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
        }
    }


    /**
     * Resets the game state and starts a new round.
     */
    function replayGame() {
        replayButton.style.display = 'none';
        // Reset player states in the active lobby for replay
        const lobby = activeLobbies[currentLobbyId];
        if (lobby) {
            lobby.playerCycles = 0; // Reset player cycles for replay
            lobby.players = lobby.players.map(p => ({
                ...p,
                lives: lobby.initialLives, // Reset lives to lobby's initial setting
                currentRoundScore: 0,
                roundCorrectAnswers: 0,
                roundTotalAnswers: 0,
                isReady: p.type === 'human' ? (lobby.isRanked ? true : false) : true, // Human ready state depends on lobby type, bots stay ready
                cards: [], // Clear cards on replay
                shields: 0, // Clear shields
                goldenDefenseUsed: false // Reset golden defense usage
            }));
            players = [...lobby.players]; // Update local player array

            // Distribute initial cards if Frenzy Mode is enabled for replay
            if (lobby.isFrenzyMode) {
                players.forEach(p => {
                    distributeInitialCards(p, 3); // Give each player 3 cards at start of replay
                });
            }

            isPlayerReady = lobby.isRanked ? true : false; // Current user ready state based on lobby type
            updateReadyButtonState(); // Update ready button state
            updateStartGameButtonState(); // Update start button status
        }
        // Redirect back to single lobby view, as replay starts a new "round" but not a new game entirely
        showSection(singleLobbyView);
    }

    /**
     * Renders player positions for the 4v4 Q&A layout.
     */
    function updatePlayerPositions4v4() {
        playerCircleDiv.innerHTML = ''; // Clear existing players

        if (players.length === 0) return;

        const radius = playerCircleDiv.offsetWidth / 2 - 70; // Adjust radius for player size
        const centerX = playerCircleDiv.offsetWidth / 2;
        const centerY = playerCircleDiv.offsetHeight / 2;

        players.forEach((player, index) => {
            const playerDiv = document.createElement('div');
            playerDiv.className = 'player';
            playerDiv.setAttribute('data-player-id', player.id);

            // Calculate position
            const angle = (index / players.length) * 2 * Math.PI;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            playerDiv.style.left = `${x}px`;
            playerDiv.style.top = `${y}px`;

            // Display lives and shields
            let livesDisplay = `Lives: ${player.lives}`;
            if (player.shields > 0) {
                livesDisplay += ` | Shields: ${player.shields}`;
            }

            playerDiv.innerHTML = `
                <div class="name ${player.id === players[currentPlayerIndex].id ? 'active' : ''}">${player.name}</div>
                <div class="lives">${livesDisplay}</div>
                ${player.shields > 0 ? '<svg class="shield-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.76-7 8.94V12H5V6.3l7-3.11v8.79z"/></svg>' : ''}
            `;
            playerCircleDiv.appendChild(playerDiv);
        });
    }

    /**
     * Renders player panels for the 1v1 Fill-in-the-Blanks layout.
     */
    function render1v1Players() {
        // Reset active player highlights and question boxes
        player1Panel.classList.remove('active-player-turn');
        player2Panel.classList.remove('active-player-turn');
        questionBox1v1Player1.style.display = 'none';
        questionBox1v1Player2.style.display = 'none';


        const player1 = players.find(p => p.id === currentUser.id); // Assuming player 1 is always the human
        const player2 = players.find(p => p.id !== currentUser.id); // Assuming player 2 is the opponent/bot

        if (!player1 || !player2) {
            console.error("Missing players for 1v1 rendering.");
            return;
        }

        // Render player 1 (human) details
        player1Name.textContent = player1.name;
        player1YouTag.textContent = "(You)";
        player1Lives.textContent = player1.lives;
        player1Elo.textContent = player1.elo;
        player1Points.textContent = player1.casualPoints;
        // Add shield display for player1
        player1Lives.innerHTML = `Lives: ${player1.lives} ${player1.shields > 0 ? `| Shields: ${player1.shields} <svg class="shield-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.76-7 8.94V12H5V6.3l7-3.11v8.79z"/></svg>` : ''}`;


        // Render player 2 (opponent/bot) details
        player2Name.textContent = player2.name;
        player2YouTag.textContent = player2.type === 'bot' ? "(Bot)" : "";
        player2Lives.textContent = player2.lives;
        player2Elo.textContent = player2.elo;
        player2Points.textContent = player2.casualPoints;
        // Add shield display for player2
        player2Lives.innerHTML = `Lives: ${player2.lives} ${player2.shields > 0 ? `| Shields: ${player2.shields} <svg class="shield-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.76-7 8.94V12H5V6.3l7-3.11v8.79z"/></svg>` : ''}`;


        // Highlight active player
        const currentPlayerTurn = players[currentPlayerIndex];
        if (currentPlayerTurn.id === player1.id) {
            player1Panel.classList.add('active-player-turn');
        } else if (currentPlayerTurn.id === player2.id) {
            player2Panel.classList.add('active-player-turn');
        }
    }

    /**
     * Updates the current round leaderboard.
     */
    function updateLeaderboard() {
        leaderboardBody.innerHTML = '';

        // Sort players by currentRoundScore, then lives, then correctAnswers
        const sortedPlayers = [...players].sort((a, b) => {
            if (b.currentRoundScore !== a.currentRoundScore) {
                return b.currentRoundScore - a.currentRoundScore;
            }
            if (b.lives !== a.lives) {
                return b.lives - a.lives;
            }
            // Use roundCorrectAnswers for in-game accuracy
            return b.roundCorrectAnswers - a.roundCorrectAnswers;
        });

        sortedPlayers.forEach((player, index) => {
            const row = leaderboardBody.insertRow();
            // Display ELO or Points based on game type
            const scoreDisplay = isRankedMatch ? player.elo : player.casualPoints;
            const accuracy = player.roundTotalAnswers > 0 ? ((player.roundCorrectAnswers / player.roundTotalAnswers) * 100).toFixed(0) : 0;
            row.innerHTML = `
                <td>${index + 1}</td>
                <td>${player.name}</td>
                <td>${scoreDisplay}</td>
                <td>${accuracy}%</td>
            `;
        });
    }

    // --- Solo Challenge Logic ---

    /**
     * Initiates and displays the solo coding challenge UI.
     */
    function selectSoloChallengeMode() {
        if (!currentUser) {
            showCustomModal("Error", "Please log in to start a challenge.");
            return;
        }
        currentLobbyType = 'solo-coding-challenge';
        isRankedMatch = false; // Solo challenge is not ranked
        isCustomMatch = false; // Solo challenge is not custom
        showSection(soloChallengeUI);
        // Load the current solo stage for the user from their in-memory data
        currentSoloStage = users[currentUser.username] ? users[currentUser.username].soloStage : 0;
        loadSoloChallenge();
    }

    /**
     * Loads and displays a specific solo challenge stage.
     */
    async function loadSoloChallenge() {
        const stageData = soloChallenges[currentSoloStage];
        if (!stageData) {
            await showCustomModal("Congratulations!", "You have completed all solo challenges!");
            soloProblemDescription.textContent = "All challenges completed!";
            soloCodeEditor.value = "";
            soloCodeEditor.disabled = true;
            soloPrevStageBtn.disabled = false;
            soloNextStageBtn.disabled = true;
            runCodeBtn.disabled = true;
            soloResult.textContent = 'All challenges completed.';
            return;
        }

        soloCurrentStageSpan.textContent = stageData.stage;
        soloProblemDescription.innerHTML = `<strong>Problem:</strong> ${stageData.problem}`;
        soloCodeEditor.value = stageData.initialCode;
        soloCodeEditor.disabled = false; // Ensure editor is enabled
        soloResult.textContent = ''; // Clear previous results

        // Update navigation buttons
        soloPrevStageBtn.disabled = currentSoloStage === 0;
        // User can only go to next stage if they've completed the current one (i.e., their saved soloStage is higher)
        soloNextStageBtn.disabled = (currentUser.soloStage <= currentSoloStage || currentSoloStage >= soloChallenges.length - 1);
        runCodeBtn.disabled = false; // Enable run button
    }

    /**
     * Navigates to the previous solo challenge stage.
     */
    function previousSoloStage() {
        if (currentSoloStage > 0) {
            currentSoloStage--;
            currentUser.soloStage = currentSoloStage; // Update currentUser and users map
            users[currentUser.username].soloStage = currentUser.soloStage;
            loadSoloChallenge();
        }
    }

    /**
     * Navigates to the next solo challenge stage.
     */
    function nextSoloStage() {
        // Allow advancing only if the user has completed the current stage
        if (currentSoloStage < currentUser.soloStage && currentSoloStage < soloChallenges.length - 1) {
            currentSoloStage++;
            currentUser.soloStage = currentSoloStage; // Update currentUser and users map
            users[currentUser.username].soloStage = currentUser.soloStage;
            loadSoloChallenge();
        } else {
            showCustomModal("Information", "Complete the current stage before moving to the next!");
        }
    }

    /**
     * Submits the user's C++ code for evaluation.
     * Integrates Gemini API for actual code evaluation.
     */
    async function submitSoloCode() {
        const code = soloCodeEditor.value;
        const stageData = soloChallenges[currentSoloStage];

        if (!stageData) {
            soloResult.textContent = 'Error: No challenge data found.';
            return;
        }
        if (!currentUser) {
            showCustomModal('Error', 'You must be logged in to submit code.');
            return;
        }

        soloResult.textContent = ''; // Clear previous result
        soloLoadingIndicator.style.display = 'block';
        runCodeBtn.disabled = true; // Disable button while running
        soloCodeEditor.disabled = true; // Disable editor while evaluating

        // Your Gemini API Key
        const apiKey = "AIzaSyA5NgYegSNZz95wbNtCKI9GnloXKCczQAw"; // <-- Your API Key is placed here

        const prompt = `Evaluate the following C++ code for the given problem.
        Problem: ${stageData.problem}
        Expected Output: ${JSON.stringify(stageData.expectedOutput)}

        User's Code:
        \`\`\`cpp
        ${code}
        \`\`\`

        Is the user's code correct and does it produce the expected output? Provide a concise "Correct!" or "Incorrect." followed by a brief explanation. If incorrect, suggest a simple fix or reason.`;

        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });

        const payload = { contents: chatHistory };
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        let geminiResponse = "Evaluation failed. Please try again.";
        let isCorrect = false;

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                geminiResponse = result.candidates[0].content.parts[0].text;
                // Simple check for "Correct!" in the response to determine if it's correct
                isCorrect = geminiResponse.toLowerCase().includes("correct!");
            } else {
                console.error("Gemini API response structure unexpected:", result);
                geminiResponse = "Evaluation failed: Unexpected API response.";
            }
        } catch (error) {
            console.error("Error calling Gemini API:", error);
            geminiResponse = `Evaluation failed due to network error or API issue: ${error.message}`;
        } finally {
            soloResult.textContent = geminiResponse;

            if (isCorrect) {
                await showCustomModal("Success", `Stage ${stageData.stage} Complete!`);
                // Only advance soloStage if they completed the current highest stage
                if (currentUser.soloStage === stageData.stage) {
                    currentUser.soloStage++; // Advance user's overall progress
                    currentUser.elo += 75; // Award ELO for solo completion
                    currentUser.tokens += 50; // Award 50 tokens for solo stage completion

                    // Update the global in-memory users object
                    users[currentUser.username].soloStage = currentUser.soloStage;
                    users[currentUser.username].elo = currentUser.elo;
                    users[currentUser.username].tokens = currentUser.tokens;

                    // Update the welcome message in the header to reflect new ELO and tokens
                    welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
                } else {
                    await showCustomModal("Information", "You already completed this stage before!");
                }
                // Automatically load next stage if successful (and if there is one)
                loadSoloChallenge();
            } else {
                await showCustomModal("Try Again", "Your code needs some adjustments. Check the evaluation for hints.");
            }

            soloLoadingIndicator.style.display = 'none';
            runCodeBtn.disabled = false; // Re-enable button
            soloCodeEditor.disabled = false; // Re-enable editor
            // Re-evaluate next stage button state
            soloNextStageBtn.disabled = (currentUser.soloStage <= currentSoloStage || currentSoloStage >= soloChallenges.length - 1);
        }
    }

    // --- Chat Functions (In-Memory per Lobby) ---
    /**
     * Sends a chat message within the current lobby.
     * @param {string} chatType The type of chat ('general', '4v4', or '1v1') to determine which chat input/display to use.
     */
    async function sendMessage(chatType) {
        let chatInput;
        let chatMessagesDiv;
        let messagesArray;

        if (chatType === '4v4') {
            chatInput = chatInput4v4;
            chatMessagesDiv = chatMessages4v4Div;
            const lobby = activeLobbies[currentLobbyId];
            messagesArray = lobby ? lobby.chatMessages : [];
        } else if (chatType === '1v1') {
            chatInput = chatInput1v1;
            chatMessagesDiv = chatMessages1v1Div;
            const lobby = activeLobbies[currentLobbyId];
            messagesArray = lobby ? lobby.chatMessages : [];
        } else {
            console.error("Unknown chat type for sendMessage:", chatType);
            await showCustomModal("Chat Error", "Invalid chat context.");
            return;
        }

        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to chat.");
            return;
        }

        if (!currentLobbyId) {
            await showCustomModal("Error", "You must be in a lobby to chat in game modes.");
            return;
        }

        const messageText = chatInput.value.trim();

        if (messageText === '') {
            return;
        }

        // Add message to the correct in-memory array
        messagesArray.push({
            senderId: currentUser.id,
            senderName: currentUser.username,
            message: messageText,
            timestamp: new Date()
        });
        chatInput.value = ''; // Clear input field

        // Re-render chat messages for the specific chat box
        renderChatMessages(chatType, messagesArray);
    }

    /**
     * Renders game-specific chat messages.
     * @param {string} layoutType The type of game layout ('4v4' or '1v1').
     * @param {Array<Object>} messages An array of message objects.
     */
    function renderChatMessages(layoutType, messages) {
        let chatMessagesDiv;
        if (layoutType === '4v4') {
            chatMessagesDiv = chatMessages4v4Div;
        }
        else if (layoutType === '1v1') {
            chatMessagesDiv = chatMessages1v1Div;
        } else {
            console.error("Unknown layout type for renderChatMessages:", layoutType);
            return;
        }

        chatMessagesDiv.innerHTML = ''; // Clear existing messages

        // Sort messages by timestamp (already sorted if pushed sequentially, but good practice)
        messages.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());

        messages.forEach(msg => {
            const msgElement = document.createElement('p');
            const timestamp = msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            msgElement.innerHTML = `<strong>[${timestamp}] ${msg.senderName}:</strong> ${msg.message}`;
            chatMessagesDiv.appendChild(msgElement);
        });
        chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; // Scroll to bottom
    }

    // --- Profile Page Functions ---
    /**
     * Displays the user's profile page.
     */
    function showProfilePage() {
        if (!currentUser) {
            showCustomModal("Error", "You must be logged in to view your profile.");
            return;
        }
        showSection(profilePage);
        updateProfilePage();
    }

    /**
     * Updates the content of the profile page with current user data.
     */
    function updateProfilePage() {
        if (!currentUser) return;

        profileAvatarText.textContent = currentUser.username.charAt(0).toUpperCase();
        profileUsernameDisplay.textContent = currentUser.username;
        profileRankedElo.textContent = currentUser.elo;
        profileCasualPoints.textContent = currentUser.casualPoints;

        const rankedAccuracy = currentUser.rankedTotalAnswers > 0 ? ((currentUser.rankedCorrectAnswers / currentUser.rankedTotalAnswers) * 100) : 0;
        profileRankedAccuracy.textContent = `${rankedAccuracy.toFixed(0)}%`;

        const casualAccuracy = currentUser.casualTotalAnswers > 0 ? ((currentUser.casualCorrectAnswers / currentUser.casualTotalAnswers) * 100).toFixed(0) : 0;
        profileCasualAccuracy.textContent = `${casualAccuracy}%`;

        profileSoloStages.textContent = currentUser.soloStage;
        profileTokens.textContent = currentUser.tokens;
        profileEquippedTitle.textContent = currentUser.equippedTitle;

        // Determine and display rank based on ranked accuracy
        let rank = 'D'; // Default rank for new players or if accuracy is 0%
        if (rankedAccuracy >= 96) {
            rank = 'S';
        } else if (rankedAccuracy >= 86) {
            rank = 'A';
        } else if (rankedAccuracy >= 76) {
            rank = 'B';
        } else if (rankedAccuracy >= 65) {
            rank = 'C';
        } else if (rankedAccuracy < 50 && currentUser.rankedTotalAnswers > 0) { // Only 'Garbage' if there are actual answers
            rank = 'Garbage';
        }
        profileRankDisplay.textContent = rank;


        // Render owned cosmetics in profile
        profileInventoryList.innerHTML = '';
        const ownedCosmetics = shopItems.filter(item => currentUser.inventory.includes(item.id) && (item.category === 'skin' || item.category === 'emote' || item.category === 'icon'));
        if (ownedCosmetics.length === 0) {
            profileInventoryList.innerHTML = '<li>No cosmetics owned.</li>';
        } else {
            ownedCosmetics.forEach(item => {
                const li = document.createElement('li');
                li.textContent = item.name;
                profileInventoryList.appendChild(li);
            });
        }
    }


    // --- Inventory Functions ---
    /**
     * Displays the inventory page and renders the user's owned items.
     */
    function showInventory() {
        if (!currentUser) {
            showCustomModal("Error", "You must be logged in to view your inventory.");
            return;
        }
        showSection(inventoryContainer);
        inventoryCurrentTokens.textContent = currentUser.tokens;
        renderInventoryItems();
    }

    /**
     * Renders the items currently in the user's inventory.
     */
    function renderInventoryItems() {
        inventoryGrid.innerHTML = ''; // Clear existing items

        if (currentUser.inventory.length === 0) {
            inventoryGrid.innerHTML = '<p style="color: #ccc; text-align: center; width: 100%;">No items in your inventory yet!</p>';
            return;
        }

        currentUser.inventory.forEach(itemId => {
            const item = shopItems.find(i => i.id === itemId);
            if (item) {
                const itemCard = document.createElement('div');
                itemCard.className = 'item-card';
                itemCard.innerHTML = `
                    <img src="${item.imageUrl}" alt="${item.name}">
                    <h3>${item.name}</h3>
                    <p>${item.description}</p>
                    <button class="primary-btn" disabled>Owned</button>
                `;
                inventoryGrid.appendChild(itemCard);
            }
        });
    }

    // --- Shop Functions ---
    let currentShopCategory = 'all'; // Default category

    /**
     * Displays the shop page and renders items available for purchase.
     */
    function showShop() {
        if (!currentUser) {
            showCustomModal("Error", "You must be logged in to view the store.");
            return;
        }
        showSection(shopContainer);
        shopCurrentTokens.textContent = currentUser.tokens;
        renderShopItems(currentShopCategory); // Render with current category
        updateShopCategoryButtons(currentShopCategory); // Highlight active button
    }

    /**
     * Renders the items available in the shop, optionally filtered by category.
     * @param {string} category The category to filter by ('all', 'skin', 'emote', 'icon', 'title', 'utility').
     */
    function renderShopItems(category = 'all') {
        shopGrid.innerHTML = ''; // Clear existing items
        currentShopCategory = category; // Update current category state

        const filteredItems = shopItems.filter(item => {
            return category === 'all' || item.category === category;
        });

        if (filteredItems.length === 0) {
            shopGrid.innerHTML = '<p style="color: #ccc; text-align: center; width: 100%;">No items in this category.</p>';
            return;
        }

        filteredItems.forEach(item => {
            const isOwned = currentUser.inventory.includes(item.id);
            const itemCard = document.createElement('div');
            itemCard.className = `item-card ${isOwned ? 'owned' : ''}`;
            itemCard.innerHTML = `
                <img src="${item.imageUrl}" alt="${item.name}">
                <h3>${item.name}</h3>
                <p>${item.description}</p>
                <p class="price">Price: ${item.price} Tokens</p>
                <button class="buy-btn ${isOwned ? 'owned' : ''}" data-item-id="${item.id}" ${isOwned ? 'disabled' : ''}>
                    ${isOwned ? 'Owned' : 'Buy'}
                </button>
            `;
            if (!isOwned) {
                itemCard.querySelector('.buy-btn').addEventListener('click', () => buyItem(item.id));
            }
            shopGrid.appendChild(itemCard);
        });
    }

    /**
     * Updates the active state of shop category buttons.
     * @param {string} activeCategory The category to mark as active.
     */
    function updateShopCategoryButtons(activeCategory) {
        shopCategoryButtons.forEach(button => {
            if (button.dataset.category === activeCategory) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });
    }

    /**
     * Handles the purchase of an item from the shop.
     * @param {string} itemId The ID of the item to purchase.
     */
    async function buyItem(itemId) {
        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to buy items.");
            return;
        }

        const item = shopItems.find(i => i.id === itemId);
        if (!item) {
            await showCustomModal("Error", "Item not found.");
            return;
        }

        if (currentUser.inventory.includes(itemId)) {
            await showCustomModal("Error", "You already own this item.");
            return;
        }

        if (currentUser.tokens < item.price) {
            await showCustomModal("Insufficient Tokens", "You don't have enough tokens to buy this item.");
            return;
        }

        const confirmed = await showCustomModal("Confirm Purchase", `Are you sure you want to buy "${item.name}" for ${item.price} tokens?`, true);
        if (!confirmed) {
            return;
        }

        currentUser.tokens -= item.price;
        currentUser.inventory.push(itemId);
        users[currentUser.username].tokens = currentUser.tokens; // Update in-memory
        users[currentUser.username].inventory = currentUser.inventory; // Update in-memory

        // If it's a title, equip it
        if (item.category === 'title') {
            currentUser.equippedTitle = item.name;
            users[currentUser.username].equippedTitle = item.name;
            await showCustomModal("Title Unlocked!", `You unlocked and equipped the title: "${item.name}"!`);
        }

        await showCustomModal("Purchase Successful!", `You bought "${item.name}"! Remaining tokens: ${currentUser.tokens}`);
        shopCurrentTokens.textContent = currentUser.tokens; // Update tokens display
        welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
        renderShopItems(currentShopCategory); // Re-render shop to update button states
    }

    // --- Code Input / Redeem Code Functions ---

    /**
     * Displays the code input modal.
     */
    function showCodeInputModal() {
        if (!currentUser) {
            showCustomModal("Error", "You must be logged in to redeem codes.");
            return;
        }
        codeInputModal.style.display = 'flex';
        codeInput.value = ''; // Clear previous input
        codeInput.focus();
    }

    /**
     * Closes the code input modal.
     */
    function closeCodeInputModal() {
        codeInputModal.style.display = 'none';
        codeInput.value = '';
    }

    /**
     * Redeems the entered code.
     */
    async function redeemCode() {
        const enteredCode = codeInput.value.trim();
        closeCodeInputModal(); // Close modal immediately

        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to redeem codes.");
            return;
        }

        if (enteredCode === "BlueLock") {
            const tokensAwarded = 50000;
            currentUser.tokens += tokensAwarded;
            users[currentUser.username].tokens = currentUser.tokens; // Update in-memory

            await showCustomModal("Code Redeemed!", `Congratulations! You received ${tokensAwarded} tokens! Your new total: ${currentUser.tokens}`);
            // Update welcome message
            welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
        } else {
            await showCustomModal("Invalid Code", "The code you entered is not valid. Please try again.");
        }
    }

    // --- Ability Card Functions (Custom Mode) ---

    /**
     * Renders the current player's ability cards.
     * @param {HTMLElement} container The DOM element to render cards into.
     */
    function renderPlayerCards(container) {
        container.innerHTML = '';
        const lobby = activeLobbies[currentLobbyId];
        if (!lobby || !lobby.isFrenzyMode) {
            container.style.display = 'none'; // Hide container if not in frenzy mode
            return;
        }
        container.style.display = 'flex'; // Show container

        const currentPlayerInGame = players.find(p => p.id === currentUser.id);
        if (!currentPlayerInGame || currentPlayerInGame.cards.length === 0) {
            container.innerHTML = '<p style="color: #ccc;">No cards in hand.</p>';
            return;
        }

        currentPlayerInGame.cards.forEach((card, index) => {
            const cardData = abilityCards.find(c => c.id === card.id);
            if (cardData) {
                const cardElement = document.createElement('div');
                cardElement.className = 'player-card-item';
                cardElement.innerHTML = `
                    ${cardData.icon}
                    <span>${cardData.name}</span>
                `;
                cardElement.onclick = () => activateCard(card.id, index);
                container.appendChild(cardElement);
            }
        });
    }

    /**
     * Distributes a random ability card to all players in the current lobby.
     */
    async function distributeRandomCard() {
        const lobby = activeLobbies[currentLobbyId];
        if (!lobby || !lobby.isFrenzyMode) return;

        await showCustomModal("New Cards!", "New ability cards have been distributed!");

        players.forEach(p => {
            // Ensure bots also get cards
            const randomCard = abilityCards[Math.floor(Math.random() * abilityCards.length)];
            p.cards.push({ id: randomCard.id, name: randomCard.name });
        });
        updateGameUI(); // Re-render to show new cards
    }

    /**
     * Distributes a specified number of random ability cards to a player.
     * @param {Object} player The player object to give cards to.
     * @param {number} count The number of cards to distribute.
     */
    function distributeInitialCards(player, count) {
        for (let i = 0; i < count; i++) {
            const randomCard = abilityCards[Math.floor(Math.random() * abilityCards.length)];
            player.cards.push({ id: randomCard.id, name: randomCard.name });
        }
    }

    /**
     * Activates a selected ability card.
     * @param {string} cardId The ID of the card to activate.
     * @param {number} cardIndex The index of the card in the player's hand.
     */
    async function activateCard(cardId, cardIndex) {
        const currentPlayerInGame = players.find(p => p.id === currentUser.id);
        if (!currentPlayerInGame) return;

        const cardElement = document.querySelector(`.player-card-item:nth-child(${cardIndex + 1})`);
        if (cardElement) {
            cardElement.classList.add('used'); // Apply burning effect
            setTimeout(() => {
                currentPlayerInGame.cards.splice(cardIndex, 1); // Remove card from hand
                updateGameUI(); // Re-render cards after animation
            }, 900); // Remove after animation completes
        } else {
            currentPlayerInGame.cards.splice(cardIndex, 1); // Fallback if element not found
            updateGameUI();
        }

        switch (cardId) {
            case 'card_copy':
                handleCopyCard();
                break;
            case 'card_control':
                handleControlCard();
                break;
            case 'card_golden_defense':
                handleGoldenDefense();
                break;
            case 'card_meta_vision':
                handleMetaVision();
                break;
            case 'card_evolved_meta_vision':
                handleEvolvedMetaVision();
                break;
            default:
                await showCustomModal("Error", "Unknown card activated.");
                break;
        }
    }

    /**
     * Implements the "Copy" card ability.
     * Grants the player a random card from the available ability cards.
     */
    async function handleCopyCard() {
        const currentPlayerInGame = players.find(p => p.id === currentUser.id);
        if (!currentPlayerInGame) return;

        const randomCard = abilityCards[Math.floor(Math.random() * abilityCards.length)];
        currentPlayerInGame.cards.push({ id: randomCard.id, name: randomCard.name });
        await showCustomModal("Card Copied!", `You gained a "${randomCard.name}" card!`);
        updateGameUI();
    }

    /**
     * Implements the "Control" card ability.
     * Allows the player to skip their current turn.
     */
    async function handleControlCard() {
        const currentPlayerInGame = players.find(p => p.id === currentUser.id);
        if (!currentPlayerInGame) return;

        const confirmed = await showCustomModal("Control Card", "Do you want to skip your turn to play safe?", true);
        if (confirmed) {
            await showCustomModal("Turn Skipped!", `${currentPlayerInGame.name} skipped their turn.`);
            // Simulate answering incorrectly to advance turn without penalty due to skip
            clearInterval(timer); // Ensure timer is stopped
            processAnswer(false); // Process as incorrect to move to next player, life will be deducted
        } else {
            // If cancelled, return the card (or don't remove it in activateCard)
            // For simplicity, we already removed it. User chose not to use it.
            // In a real game, you'd re-add the card or prevent removal if not confirmed.
            await showCustomModal("Action Cancelled", "Your turn will proceed as normal.");
            startTimer(); // Restart timer if cancelled
        }
    }

    /**
     * Implements the "Golden Defense" card ability.
     * Grants the player 2 shields for the current game. Can only be used once.
     */
    async function handleGoldenDefense() {
        const currentPlayerInGame = players.find(p => p.id === currentUser.id);
        if (!currentPlayerInGame || currentPlayerInGame.goldenDefenseUsed) {
            await showCustomModal("Golden Defense", "You have already used Golden Defense this game.");
            return;
        }
        currentPlayerInGame.shields = 2;
        currentPlayerInGame.goldenDefenseUsed = true;
        await showCustomModal("Golden Defense Activated!", `${currentPlayerInGame.name} gained 2 shields!`);
        updateGameUI();
    }

    /**
     * Implements the "Meta Vision" card ability.
     * Displays all opponents' current cards in a modal.
     */
    async function handleMetaVision() {
        const currentPlayerInGame = players.find(p => p.id === currentUser.id);
        if (!currentPlayerInGame) return;

        metaVisionPlayerDecks.innerHTML = ''; // Clear previous content
        const opponents = players.filter(p => p.id !== currentPlayerInGame.id);

        if (opponents.length === 0) {
            metaVisionPlayerDecks.innerHTML = '<p>No opponents to view.</p>';
        } else {
            opponents.forEach(opponent => {
                const deckDiv = document.createElement('div');
                deckDiv.className = 'meta-vision-player-deck';
                deckDiv.innerHTML = `<h4>${opponent.name}'s Hand:</h4><div class="card-list"></div>`;
                const cardListDiv = deckDiv.querySelector('.card-list');

                if (opponent.cards.length === 0) {
                    cardListDiv.innerHTML = '<span>No cards</span>';
                } else {
                    opponent.cards.forEach(card => {
                        const cardSpan = document.createElement('span');
                        cardSpan.textContent = card.name;
                        cardListDiv.appendChild(cardSpan);
                    });
                }
                metaVisionPlayerDecks.appendChild(deckDiv);
            });
        }
        metaVisionOverlay.style.display = 'flex';
    }

    /**
     * Closes the Meta Vision overlay.
     */
    function closeMetaVision() {
        metaVisionOverlay.style.display = 'none';
    }

    /**
     * Implements the "Evolved Meta Vision" card ability.
     * Sets a flag to provide a hint on the next question.
     */
    async function handleEvolvedMetaVision() {
        const currentPlayerInGame = players.find(p => p.id === currentUser.id);
        if (!currentPlayerInGame) return;

        currentPlayerInGame.hasEvolvedMetaVision = true; // Flag to be used in updateGameUI
        await showCustomModal("Evolved Meta Vision Activated!", "You will receive a clue for the next question!");
    }


    // --- Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
        // Initial UI state: show auth container
        showSection(authContainer);

        // Authentication buttons
        authSubmitBtn.addEventListener('click', authAction);
        authSwitch.addEventListener('click', toggleAuthMode);
        logoutBtn.addEventListener('click', logout);

        // Main Lobby Dashboard buttons
        casualModeBtn.addEventListener('click', () => showSection(gameModeSelection));
        rankedModeBtn.addEventListener('click', () => showSection(rankedGameModeSelection)); // Modified to show ranked mode selection
        // Custom mode now goes to a specific lobby list with custom settings
        document.getElementById('customModeBtn').addEventListener('click', () => showLobbyList('custom-qna')); // Default to custom Q&A for now

        // Top right icons
        profileIcon.addEventListener('click', showProfilePage);
        inventoryIcon.addEventListener('click', showInventory);
        shopIcon.addEventListener('click', showShop);
        codeInputIcon.addEventListener('click', showCodeInputModal);

        // Shop category filter buttons
        shopCategoryButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const category = e.target.dataset.category;
                renderShopItems(category);
                updateShopCategoryButtons(category);
            });
        });


        // Game Mode Selection buttons (Casual)
        document.getElementById('four-v-four-qna-mode').addEventListener('click', () => showLobbyList('free-for-all-qna'));
        document.getElementById('one-v-one-fill-in-blanks-mode').addEventListener('click', () => showLobbyList('1v1-fill-in-blanks'));
        document.getElementById('solo-coding-challenge-mode').addEventListener('click', selectSoloChallengeMode);

        // Game Mode Selection buttons (Ranked) - New
        document.getElementById('ranked-four-v-four-qna-mode').addEventListener('click', () => initiateRankedMatch('ranked-free-for-all-qna'));
        document.getElementById('ranked-one-v-one-fill-in-blanks-mode').addEventListener('click', () => initiateRankedMatch('ranked-1v1-fill-in-blanks'));

        // Back to Dashboard buttons (now multiple)
        backToDashboardBtns.forEach(btn => {
            btn.addEventListener('click', backToDashboard);
        });

        // Lobby List and Single Lobby View buttons
        document.querySelector('.back-to-mode-selection-btn').addEventListener('click', backToModeSelection);
        createNewLobbyBtn.addEventListener('click', createNewLobby);
        confirmCreateLobbyBtn.addEventListener('click', confirmCreateLobby);
        cancelCreateLobbyBtn.addEventListener('click', closeCreateLobbyModal);
        document.querySelector('.back-to-lobbies-btn').addEventListener('click', leaveLobby);
        readyToggleBtn.addEventListener('click', toggleReady);
        startGameButton.addEventListener('click', startGame);

        // In-Game Buttons (4v4)
        document.getElementById('backToLobbyBtn4v4').addEventListener('click', leaveGame);
        submitAnswerBtn4v4.addEventListener('click', submitAnswer);
        replayButton.addEventListener('click', replayGame);

        // In-Game Buttons (1v1)
        document.getElementById('backToLobbyBtn1v1').addEventListener('click', leaveGame);
        submitAnswerBtn1v1Player1.addEventListener('click', submitAnswer); // User's submit button
        // submitAnswerBtn1v1Player2.addEventListener('click', submitAnswer); // Bot's submit button (will be disabled for user)

        // Solo Challenge buttons
        soloBackToLobbyBtn.addEventListener('click', leaveSoloChallenge);
        soloPrevStageBtn.addEventListener('click', previousSoloStage);
        soloNextStageBtn.addEventListener('click', nextSoloStage);
        runCodeBtn.addEventListener('click', submitSoloCode);

        // Chat buttons
        sendChatBtn4v4.addEventListener('click', () => sendMessage('4v4'));
        chatInput4v4.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage('4v4');
        });
        sendChatBtn1v1.addEventListener('click', () => sendMessage('1v1'));
        chatInput1v1.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage('1v1');
        });

        // Code Input Modal buttons
        redeemCodeBtn.addEventListener('click', redeemCode);
        cancelCodeBtn.addEventListener('click', closeCodeInputModal);
        codeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') redeemCode();
        });


        // Global Enter key listeners for inputs
        usernameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') passwordInput.focus(); });
        passwordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') authAction(); });
        answerInput4v4.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitAnswer(); });
        answerInput1v1Player1.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitAnswer(); });
        // answerInput1v1Player2.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitAnswer(); }); // For bot's panel
        soloCodeEditor.addEventListener('keypress', (e) => {
            // Allow new lines in textarea, only submit on Ctrl+Enter or similar if desired
            // For now, no auto-submit on Enter for code editor
        });
    });

    // Initial check when the page loads
    window.onload = function() {
        // Initial UI state: show auth container
        showSection(authContainer);
        // Request global leaderboard data on load (now uses local data)
        updateGlobalLeaderboard();
    };
</script>
</body>
</html>
