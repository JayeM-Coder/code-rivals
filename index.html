<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Code Rivals - C++ Challenge</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&amp;display=swap" rel="stylesheet"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
<style>
    body {
        margin: 0;
        padding: 0;
        background: radial-gradient(circle at center, #001f3f, #000);
        font-family: 'Inter', sans-serif;
        color: #00ccff;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        width: 100vw;
        overflow-x: hidden; 
        overflow-y: auto; 
    }

    h1, h2, h3 {
        font-family: 'Orbitron', sans-serif; 
        text-shadow: 0 0 10px #00ccff;
        color: #00ccff;
    }

  
    .hidden {
        display: none !important;
    }

    .section-container {
        display: none; 
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 90%;
        max-width: 800px;
        margin: 20px auto;
        padding: 30px;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 15px;
        box-shadow: 0 0 20px rgba(0, 204, 255, 0.5);
        border: 1px solid #00ccff;
        animation: fadeIn 0.5s ease-out;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        justify-content: center;
        margin-top: 20px;
    }

    .primary-btn, .secondary-btn {
        padding: 12px 25px;
        border: none;
        border-radius: 8px;
        font-family: 'Orbitron', sans-serif;
        font-size: 1em;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .primary-btn {
        background: linear-gradient(45deg, #007bff, #00ccff);
        color: white;
        border: 1px solid #00ccff;
    }

    .primary-btn:hover {
        background: linear-gradient(45deg, #00ccff, #007bff);
        box-shadow: 0 6px 20px rgba(0, 204, 255, 0.7);
        transform: translateY(-2px);
    }

    .primary-btn:disabled {
        background: #333;
        color: #888;
        border-color: #555;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
    }

    .secondary-btn {
        background: linear-gradient(45deg, #555, #333);
        color: #00ccff;
        border: 1px solid #00ccff;
    }

    .secondary-btn:hover {
        background: linear-gradient(45deg, #333, #555);
        box-shadow: 0 6px 20px rgba(0, 204, 255, 0.3);
        transform: translateY(-2px);
    }

    .secondary-btn:disabled {
        background: #333;
        color: #888;
        border-color: #555;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select {
        width: calc(100% - 20px);
        padding: 10px;
        margin-bottom: 15px;
        border: 1px solid #00ccff;
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.5);
        color: #00ccff;
        font-size: 1em;
        box-sizing: border-box;
    }

    input[type="text"]::placeholder,
    input[type="password"]::placeholder,
    textarea::placeholder {
        color: #007bff;
        opacity: 0.7;
    }

    label {
        display: block;
        margin-bottom: 5px;
        color: #00ccff;
        font-weight: 600;
    }

    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
        margin-left: 10px;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 34px;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }

    input:checked + .slider {
        background-color: #00ccff;
    }

    input:focus + .slider {
        box-shadow: 0 0 1px #00ccff;
    }

    input:checked + .slider:before {
        transform: translateX(26px);
    }

    header {
        width: 100%;
        padding: 15px 20px;
        background: rgba(0, 0, 0, 0.8);
        box-shadow: 0 2px 10px rgba(0, 204, 255, 0.3);
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: fixed; 
        top: 0;
        left: 0;
        z-index: 1000;
        box-sizing: border-box;
    }

    .header-title {
        font-family: 'Orbitron', sans-serif;
        font-size: 1.8em;
        color: #00ccff;
        text-shadow: 0 0 8px #00ccff;
        margin: 0;
    }

    .header-controls {
        display: flex;
        align-items: center;
        gap: 15px;
    }

    .header-controls button {
        background: none;
        border: none;
        color: #00ccff;
        font-size: 1.2em;
        cursor: pointer;
        transition: color 0.3s ease, transform 0.3s ease;
    }

    .header-controls button:hover {
        color: #007bff;
        transform: scale(1.1);
    }

    .header-controls .welcome-message {
        font-size: 0.9em;
        color: #aaa;
        margin-right: 10px;
    }


    #authContainer {
        margin-top: 100px; 
    }

    #authContainer h2 {
        margin-bottom: 25px;
        text-align: center;
    }

    #authContainer .form-group {
        margin-bottom: 15px;
    }

    #authContainer .auth-toggle {
        text-align: center;
        margin-top: 20px;
        color: #ccc;
    }

    #authContainer .auth-toggle a {
        color: #00ccff;
        text-decoration: none;
        font-weight: 600;
    }

    #authContainer .auth-toggle a:hover {
        text-decoration: underline;
    }


    #gameModeSelection {
        margin-top: 100px;
    }

    #gameModeSelection h2 {
        margin-bottom: 25px;
        text-align: center;
    }

 
    #lobbyListContainer {
        margin-top: 100px; 
        align-items: flex-start; 
    }

    #lobbyListContainer h2 {
        width: 100%;
        text-align: center;
        margin-bottom: 25px;
    }

    #lobbiesGrid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        width: 100%;
        padding: 10px;
    }

    .lobby-card {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #00ccff;
        border-radius: 10px;
        padding: 20px;
        text-align: center;
        box-shadow: 0 0 10px rgba(0, 204, 255, 0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .lobby-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0, 204, 255, 0.5);
    }

    .lobby-card.full {
        opacity: 0.7;
        background: rgba(50, 0, 0, 0.5);
        border-color: #ff0000;
    }

    .lobby-card.full .join-btn {
        background: #880000;
        cursor: not-allowed;
    }

    .lobby-card h3 {
        margin-top: 0;
        color: #00ccff;
    }

    .lobby-card p {
        margin: 5px 0;
        color: #ccc;
    }

    .lobby-card .join-btn {
        margin-top: 15px;
        width: 100%;
    }

    #singleLobbyView {
        margin-top: 100px;
        align-items: flex-start;
    }

    #singleLobbyView h2 {
        width: 100%;
        text-align: center;
        margin-bottom: 20px;
    }

    #lobbyInfo {
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 100%;
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 10px;
        border: 1px solid #00ccff;
    }

    #lobbyInfo p {
        margin: 0;
        color: #ccc;
    }

    #lobbyPlayers {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
        margin-top: 20px;
    }

    .player-card {
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid #007bff;
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        box-shadow: 0 0 8px rgba(0, 123, 255, 0.3);
    }

    .player-card.ready {
        border-color: #00ccff;
        box-shadow: 0 0 8px rgba(0, 204, 255, 0.5);
    }

    .player-card h4 {
        margin: 5px 0;
        color: #00ccff;
    }

    .player-card p {
        margin: 3px 0;
        font-size: 0.9em;
        color: #ccc;
    }

    #gameUI4v4, #gameUI1v1 {
        margin-top: 100px; 
        align-items: flex-start;
        display: none; 
    }

    #gameUI4v4 .game-header, #gameUI1v1 .game-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 10px;
        border: 1px solid #00ccff;
    }

    .game-header h3 {
        margin: 0;
        color: #00ccff;
    }

    .game-header .timer {
        font-family: 'Orbitron', sans-serif;
        font-size: 1.8em;
        color: #ffcc00;
        text-shadow: 0 0 10px #ffcc00;
    }

    #questionBox4v4, #questionBox1v1Player1, #questionBox1v1Player2 {
        width: 100%;
        min-height: 120px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #00ccff;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        box-shadow: 0 0 15px rgba(0, 204, 255, 0.4);
    }

    #questionBox4v4 p, #questionBox1v1Player1 p, #questionBox1v1Player2 p {
        font-size: 1.2em;
        font-weight: 600;
        margin: 0;
        color: #fff;
    }

    #questionBox4v4 .hint, #questionBox1v1Player1 .hint, #questionBox1v1Player2 .hint {
        font-size: 0.9em;
        color: #aaa;
        margin-top: 10px;
    }

    .player-circle-container {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 20px;
        width: 100%;
    }

    .player-circle {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.6);
        border: 2px solid #007bff;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 0.8em;
        color: #fff;
        text-align: center;
        position: relative;
        box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
        transition: all 0.3s ease;
    }

    .player-circle.current-turn {
        border-color: #ffcc00;
        box-shadow: 0 0 15px rgba(255, 204, 0, 0.7);
        transform: scale(1.1);
    }

    .player-circle.eliminated {
        opacity: 0.5;
        background: rgba(50, 0, 0, 0.6);
        border-color: #ff0000;
        text-decoration: line-through;
    }

    .player-circle .lives-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        background-color: #ff0000;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7em;
        font-weight: bold;
    }

    .player-circle .shields-indicator {
        position: absolute;
        bottom: 5px;
        left: 5px;
        background-color: #00ccff;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7em;
        font-weight: bold;
    }

    .game-controls {
        display: flex;
        gap: 15px;
        width: 100%;
        justify-content: center;
        margin-top: 20px;
    }

    .game-controls .primary-btn {
        flex-grow: 1;
    }


    #gameUI1v1 .player-panels {
        display: flex;
        justify-content: space-around;
        width: 100%;
        gap: 20px;
        flex-wrap: wrap;
    }

    #gameUI1v1 .player-panel {
        flex: 1;
        min-width: 300px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #00ccff;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 0 15px rgba(0, 204, 255, 0.4);
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    #gameUI1v1 .player-panel h3 {
        margin-top: 0;
        color: #00ccff;
    }

    #gameUI1v1 .player-panel .stats p {
        margin: 5px 0;
        color: #ccc;
    }

    #gameUI1v1 .player-panel .input-group {
        width: 100%;
        margin-top: 15px;
    }

    #gameUI1v1 .player-panel .input-group input {
        width: calc(100% - 20px);
    }

    #soloChallengeUI {
        margin-top: 100px;
        align-items: flex-start;
    }

    #soloChallengeUI h2 {
        width: 100%;
        text-align: center;
        margin-bottom: 20px;
    }

    #soloProblemDescription {
        width: 100%;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #00ccff;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 0 15px rgba(0, 204, 255, 0.4);
        color: #fff;
    }

    #soloProblemDescription h3 {
        margin-top: 0;
        color: #00ccff;
    }

    #soloProblemDescription pre {
        background-color: rgba(0, 0, 0, 0.7);
        border: 1px solid #007bff;
        padding: 10px;
        border-radius: 5px;
        overflow-x: auto;
        color: #eee;
    }

    #soloCodeEditor {
        width: 100%;
        height: 300px;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 0.9em;
        background-color: #1a1a1a;
        border: 1px solid #00ccff;
        border-radius: 8px;
        color: #00ff00;
        padding: 15px;
        resize: vertical;
        margin-bottom: 15px;
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
    }

    #soloResult {
        width: 100%;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #00ccff;
        border-radius: 10px;
        padding: 15px;
        margin-top: 15px;
        min-height: 50px;
        color: #fff;
        font-family: 'Consolas', 'Monaco', monospace;
        white-space: pre-wrap; 
        word-wrap: break-word;
    }

    #soloLoadingIndicator {
        display: none;
        text-align: center;
        margin-top: 10px;
        color: #ffcc00;
    }

    .solo-controls {
        display: flex;
        justify-content: space-between;
        width: 100%;
        margin-top: 15px;
    }

    #globalLeaderboard {
        margin-top: 100px;
        align-items: flex-start;
    }

    #globalLeaderboard h2 {
        width: 100%;
        text-align: center;
        margin-bottom: 20px;
    }

    #globalLeaderboard table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        overflow: hidden;
    }

    #globalLeaderboard th, #globalLeaderboard td {
        padding: 12px 15px;
        text-align: left;
        border-bottom: 1px solid #007bff;
        color: #eee;
    }

    #globalLeaderboard th {
        background-color: #001f3f;
        color: #00ccff;
        font-family: 'Orbitron', sans-serif;
        text-transform: uppercase;
        font-size: 0.9em;
    }

    #globalLeaderboard tr:nth-child(even) {
        background-color: rgba(0, 0, 0, 0.3);
    }

    #globalLeaderboard tr:hover {
        background-color: rgba(0, 204, 255, 0.1);
    }

    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
    }

    .modal-content {
        background: #001f3f;
        border: 2px solid #00ccff;
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 0 30px rgba(0, 204, 255, 0.7);
        text-align: center;
        max-width: 500px;
        width: 90%;
        color: #fff;
        animation: modalPopIn 0.3s ease-out;
        position: relative;
    }

    @keyframes modalPopIn {
        from { transform: scale(0.8); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
    }

    .modal-content h3 {
        color: #00ccff;
        margin-top: 0;
        margin-bottom: 20px;
    }

    .modal-content p {
        margin-bottom: 25px;
        line-height: 1.6;
    }

    .modal-content .button-group {
        margin-top: 0;
    }

    .modal-close-btn {
        position: absolute;
        top: 10px;
        right: 15px;
        background: none;
        border: none;
        font-size: 1.8em;
        color: #00ccff;
        cursor: pointer;
        transition: color 0.2s ease;
    }

    .modal-close-btn:hover {
        color: #ff0000;
    }

    #createLobbyModal .form-group {
        margin-bottom: 15px;
        text-align: left;
        width: 100%;
    }

    #createLobbyModal .form-group label {
        margin-bottom: 8px;
        font-size: 1.1em;
    }

    #createLobbyModal .form-group input,
    #createLobbyModal .form-group select {
        width: 100%;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid #007bff;
        background-color: rgba(0, 0, 0, 0.6);
        color: #fff;
        font-size: 1em;
    }

    #createLobbyModal .form-group input:focus,
    #createLobbyModal .form-group select:focus {
        outline: none;
        border-color: #00ccff;
        box-shadow: 0 0 8px rgba(0, 204, 255, 0.5);
    }

    #createLobbyModal .form-group input[type="checkbox"] {
        width: auto;
        margin-right: 10px;
    }

    .form-group .checkbox-label {
        display: flex;
        align-items: center;
        color: #ccc;
        font-weight: normal;
    }

    .floating-chat {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 300px;
        height: 400px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #00ccff;
        border-radius: 10px;
        box-shadow: 0 0 15px rgba(0, 204, 255, 0.5);
        display: flex;
        flex-direction: column;
        z-index: 1500;
        overflow: hidden; 
    }

    .chat-header {
        background: rgba(0, 0, 0, 0.9);
        padding: 10px 15px;
        border-bottom: 1px solid #00ccff;
        color: #00ccff;
        font-family: 'Orbitron', sans-serif;
        cursor: grab;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .chat-header:active {
        cursor: grabbing;
    }

    .chat-content {
        flex-grow: 1;
        padding: 15px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .chat-message {
        background: rgba(0, 123, 255, 0.2);
        padding: 8px 12px;
        border-radius: 15px;
        align-self: flex-start;
        max-width: 80%;
        word-wrap: break-word;
        color: #eee;
    }

    .chat-message.self {
        background: rgba(0, 204, 255, 0.3);
        align-self: flex-end;
    }

    .chat-message .sender-name {
        font-weight: bold;
        color: #00ccff;
        margin-bottom: 5px;
        display: block;
    }

    .chat-input-area {
        display: flex;
        padding: 10px;
        border-top: 1px solid #00ccff;
        background: rgba(0, 0, 0, 0.9);
    }

    .chat-input-area input {
        flex-grow: 1;
        margin-bottom: 0;
        border-radius: 5px 0 0 5px;
        border-right: none;
    }

    .chat-input-area button {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 0 5px 5px 0;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }

    .chat-input-area button:hover {
        background: #00ccff;
    }

    .sticker-panel {
        display: none; 
        flex-wrap: wrap;
        gap: 10px;
        padding: 10px;
        border-top: 1px solid #00ccff;
        background: rgba(0, 0, 0, 0.9);
        max-height: 150px;
        overflow-y: auto;
        justify-content: center;
    }

    .sticker-panel img {
        width: 50px;
        height: 50px;
        object-fit: contain;
        border: 1px solid #007bff;
        border-radius: 5px;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .sticker-panel img:hover {
        transform: scale(1.1);
        box-shadow: 0 0 8px #00ccff;
    }

    .sticker {
        max-width: 150px; 
        height: auto;
        border-radius: 5px;
        display: block; 
    }

    #shopContainer {
        margin-top: 100px;
        align-items: flex-start;
    }

    #shopContainer h2 {
        width: 100%;
        text-align: center;
        margin-bottom: 20px;
    }

    .shop-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 10px;
        border: 1px solid #00ccff;
    }

    .shop-header h3 {
        margin: 0;
        color: #00ccff;
    }

    .shop-header .tokens-display {
        font-family: 'Orbitron', sans-serif;
        font-size: 1.2em;
        color: #ffcc00;
        text-shadow: 0 0 8px #ffcc00;
    }

    .shop-categories {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
        width: 100%;
    }

    .shop-categories button {
        background: rgba(0, 123, 255, 0.3);
        color: #00ccff;
        border: 1px solid #007bff;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .shop-categories button.active,
    .shop-categories button:hover {
        background: #007bff;
        color: white;
        box-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
    }

    #shopItemsGrid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        width: 100%;
        padding: 10px;
    }

    .shop-item-card {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #00ccff;
        border-radius: 10px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 0 10px rgba(0, 204, 255, 0.3);
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }

    .shop-item-card h3 {
        margin-top: 0;
        color: #00ccff;
        font-size: 1.1em;
    }

    .shop-item-card p {
        margin: 5px 0;
        color: #ccc;
        font-size: 0.9em;
    }

    .shop-item-card .item-price {
        font-family: 'Orbitron', sans-serif;
        color: #ffcc00;
        font-size: 1.1em;
        margin: 10px 0;
    }

    .shop-item-card .buy-btn {
        margin-top: 10px;
        width: 100%;
    }

    .shop-item-card .buy-btn:disabled {
        background: #333;
        color: #888;
        border-color: #555;
        cursor: not-allowed;
    }

    #codeInputModal .form-group {
        margin-bottom: 15px;
        text-align: left;
        width: 100%;
    }

    #codeInputModal .form-group label {
        margin-bottom: 8px;
        font-size: 1.1em;
    }

    #codeInputModal .form-group input {
        width: 100%;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid #007bff;
        background-color: rgba(0, 0, 0, 0.6);
        color: #fff;
        font-size: 1em;
    }


    #profilePage {
        margin-top: 100px; 
        align-items: flex-start;
    }

    #profilePage h2 {
        width: 100%;
        text-align: center;
        margin-bottom: 20px;
    }

    .profile-info {
        width: 100%;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid #00ccff;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 0 15px rgba(0, 204, 255, 0.4);
        color: #fff;
    }

    .profile-info p {
        margin: 10px 0;
        font-size: 1.1em;
    }

    .profile-info p strong {
        color: #00ccff;
    }

    .profile-stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        width: 100%;
        margin-top: 20px;
    }

    .stat-card {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #007bff;
        border-radius: 10px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
    }

    .stat-card h4 {
        margin-top: 0;
        color: #00ccff;
        font-size: 1em;
    }

    .stat-card p {
        margin: 5px 0;
        font-size: 1.2em;
        font-family: 'Orbitron', sans-serif;
        color: #ffcc00;
    }

    .profile-inventory {
        width: 100%;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid #00ccff;
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 0 15px rgba(0, 204, 255, 0.4);
        color: #fff;
    }

    .profile-inventory h3 {
        margin-top: 0;
        color: #00ccff;
        text-align: center;
        margin-bottom: 15px;
    }

    .inventory-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 10px;
        justify-content: center;
    }

    .inventory-item {
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid #007bff;
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        font-size: 0.9em;
        color: #ccc;
        box-shadow: 0 0 5px rgba(0, 123, 255, 0.2);
    }

    .inventory-item.equipped {
        border-color: #ffcc00;
        box-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        font-weight: bold;
    }

    /* Responsive Adjustments */
    @media (max-width: 768px) {
        .header-title {
            font-size: 1.5em;
        }

        .header-controls {
            gap: 10px;
        }

        .primary-btn, .secondary-btn {
            padding: 10px 20px;
            font-size: 0.9em;
        }

        .section-container {
            padding: 20px;
            width: 95%;
        }

        .lobby-card {
            padding: 15px;
        }

        #lobbiesGrid, #shopItemsGrid, .profile-stats-grid, .inventory-grid {
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        .player-circle {
            width: 70px;
            height: 70px;
            font-size: 0.7em;
        }

        #gameUI1v1 .player-panel {
            min-width: unset;
            width: 100%;
        }

        .floating-chat {
            width: 90%;
            right: 5%;
            left: 5%;
            bottom: 10px;
            height: 350px;
        }
    }

    @media (max-width: 480px) {
        .header-title {
            font-size: 1.2em;
        }

        .header-controls {
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        .welcome-message {
            display: none; 
        }

        .primary-btn, .secondary-btn {
            width: 100%;
            margin-bottom: 10px;
        }

        .button-group {
            flex-direction: column;
        }

        #lobbiesGrid, #shopItemsGrid, .profile-stats-grid, .inventory-grid {
            grid-template-columns: 1fr;
        }
    }
</style>
</head>
<body>
    <header>
        <h1 class="header-title">Code Rivals</h1>
        <div class="header-controls">
            <span id="welcomeMessage" class="welcome-message hidden"></span>
            <button id="profileIcon" class="hidden" title="Profile"><i class="fas fa-user"></i></button>
            <button id="inventoryIcon" class="hidden" title="Inventory"><i class="fas fa-box-open"></i></button>
            <button id="shopIcon" class="hidden" title="Shop"><i class="fas fa-store"></i></button>
            <button id="codeInputIcon" class="hidden" title="Redeem Code"><i class="fas fa-gift"></i></button>
            <button id="logoutBtn" class="hidden" title="Logout"><i class="fas fa-sign-out-alt"></i></button>
        </div>
    </header>

    <section id="authContainer" class="section-container">
        <h2>Welcome to Code Rivals</h2>
        <div class="form-group">
            <label for="usernameInput">Username:</label>
            <input type="text" id="usernameInput" placeholder="Enter your username"/>
        </div>
        <div class="form-group">
            <label for="passwordInput">Password:</label>
            <input type="password" id="passwordInput" placeholder="Enter your password"/>
        </div>
        <div class="button-group">
            <button id="authActionBtn" class="primary-btn">Login</button>
        </div>
        <p class="auth-toggle">
            <span id="authToggleText">Don't have an account?</span>
            <a href="#" id="toggleAuthMode">Sign Up</a>
        </p>
    </section>

    <section id="gameModeSelection" class="section-container hidden">
        <h2>Choose Your Challenge</h2>
        <div class="button-group">
            <button class="primary-btn" id="freeForAllQnABtn">Free for All Q&A</button>
            <button class="primary-btn" id="oneVOneFillInBlanksBtn">1v1 Fill in the Blanks</button>
            <button class="primary-btn" id="soloCodingChallengeBtn">Solo Coding Challenge</button>
            <button class="primary-btn" id="rankedFreeForAllQnABtn">Ranked Free for All Q&A</button>
            <button class="primary-btn" id="rankedOneVOneFillInBlanksBtn">Ranked 1v1 Fill in the Blanks</button>
            <button class="secondary-btn" id="customGameBtn">Custom Game</button>
            <button class="secondary-btn" id="globalLeaderboardBtn">Global Leaderboard</button>
        </div>
    </section>

    <section id="lobbyListContainer" class="section-container hidden">
        <h2 id="lobbyListTitle">Available Lobbies</h2>
        <div class="button-group">
            <button class="primary-btn" id="createLobbyBtn">Create New Lobby</button>
            <button class="secondary-btn" id="backToGameModesBtn">Back to Modes</button>
        </div>
        <div id="lobbiesGrid">
        </div>
    </section>

    <section id="singleLobbyView" class="section-container hidden">
        <h2 id="currentLobbyTitle">Lobby: [Lobby Name]</h2>
        <div id="lobbyInfo">
            <p>Lobby ID: <span id="displayLobbyId"></span></p>
            <p>Players: <span id="displayPlayerCount">0</span>/<span id="displayMaxPlayers">0</span></p>
            <p>Status: <span id="displayLobbyStatus">Waiting</span></p>
        </div>
        <div id="lobbyPlayers">
        </div>
        <div class="button-group">
            <button class="primary-btn" id="readyBtn">Ready</button>
            <button class="primary-btn" id="startGameBtn">Start Game</button>
            <button class="secondary-btn" id="leaveLobbyBtn">Leave Lobby</button>
        </div>
    </section>

    <section id="gameUI4v4" class="section-container hidden">
        <div class="game-header">
            <h3>Game In Progress (Q&A)</h3>
            <span class="timer">Time: <span id="gameTimerDisplay4v4">30</span>s</span>
        </div>
        <div id="questionBox4v4">
            <p id="currentQuestion4v4">Question will appear here...</p>
            <p class="hint" id="currentHint4v4" style="display: none;"></p>
        </div>
        <div class="player-circle-container" id="playerCircleDiv4v4">
        </div>
        <div class="input-group">
            <input type="text" id="answerInput4v4" placeholder="Type your answer here..." autocomplete="off"/>
        </div>
        <div class="button-group game-controls">
            <button class="primary-btn" id="submitAnswerBtn4v4">Submit Answer</button>
            <button class="secondary-btn" id="leaveGameBtn4v4">Leave Game</button>
        </div>
        <div id="playerCardsContainer4v4" class="player-cards-container">
        </div>
    </section>

    <section id="gameUI1v1" class="section-container hidden">
        <div class="game-header">
            <h3>Game In Progress (Fill in the Blanks)</h3>
            <span class="timer">Time: <span id="gameTimerDisplay1v1">30</span>s</span>
        </div>
        <div class="player-panels">
            <div class="player-panel">
                <h3 id="player1Name">Player 1</h3>
                <div class="stats">
                    <p>Lives: <span id="player1Lives">3</span></p>
                    <p>Score: <span id="player1Score">0</span></p>
                </div>
                <div id="questionBox1v1Player1">
                    <p id="currentQuestion1v1Player1">Question will appear here...</p>
                    <p class="hint" id="currentHint1v1Player1" style="display: none;"></p>
                </div>
                <div class="input-group">
                    <input type="text" id="answerInput1v1Player1" placeholder="Type your answer here..." autocomplete="off"/>
                </div>
                <div class="button-group">
                    <button class="primary-btn" id="submitAnswerBtn1v1Player1">Submit Answer</button>
                </div>
                <div id="playerCardsContainer1v1" class="player-cards-container">
                </div>
            </div>

            <div class="player-panel">
                <h3 id="player2Name">Player 2</h3>
                <div class="stats">
                    <p>Lives: <span id="player2Lives">3</span></p>
                    <p>Score: <span id="player2Score">0</span></p>
                </div>
                <div id="questionBox1v1Player2">
                    <p id="currentQuestion1v1Player2">Opponent's question will appear here...</p>
                </div>
            </div>
        </div>
        <div class="button-group game-controls">
            <button class="secondary-btn" id="leaveGameBtn1v1">Leave Game</button>
        </div>
    </section>

    <section id="soloChallengeUI" class="section-container hidden">
        <h2>Solo Coding Challenge - Stage <span id="soloStageDisplay">1</span></h2>
        <div id="soloProblemDescription">
            <h3>Problem:</h3>
            <p id="soloProblemText">Problem description will appear here.</p>
            <h3>Expected Output:</h3>
            <pre id="soloExpectedOutput">Expected output will appear here.</pre>
        </div>
        <textarea id="soloCodeEditor" placeholder="Write your C++ code here..."></textarea>
        <div id="soloLoadingIndicator">Evaluating code...</div>
        <div id="soloResult"></div>
        <div class="solo-controls">
            <button class="primary-btn" id="runCodeBtn">Run Code</button>
            <button class="secondary-btn" id="soloNextStageBtn" disabled>Next Stage</button>
            <button class="secondary-btn" id="soloBackToModesBtn">Back to Modes</button>
        </div>
    </section>


    <section id="globalLeaderboard" class="section-container hidden">
        <h2>Global Leaderboard</h2>
        <table>
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Username</th>
                    <th>ELO</th>
                    <th>Accuracy</th>
                </tr>
            </thead>
            <tbody id="globalLeaderboardBody">
       
            </tbody>
        </table>
        <div class="button-group">
            <button class="secondary-btn" id="backFromLeaderboardBtn">Back to Modes</button>
        </div>
    </section>


    <section id="shopContainer" class="section-container hidden">
        <div class="shop-header">
            <h2>Shop</h2>
            <span class="tokens-display">Tokens: <span id="shopCurrentTokens">0</span></span>
        </div>
        <div class="shop-categories">
            <button class="primary-btn active" data-category="all" id="showAllItemsBtn">All</button>
            <button class="primary-btn" data-category="title" id="showTitlesBtn">Titles</button>
            <button class="primary-btn" data-category="ability" id="showAbilitiesBtn">Abilities</button>
        </div>
        <div id="shopItemsGrid">
      
        </div>
        <div class="button-group">
            <button class="secondary-btn" id="backFromShopBtn">Back to Modes</button>
        </div>
    </section>


    <section id="profilePage" class="section-container hidden">
        <h2>Your Profile</h2>
        <div class="profile-info">
            <p><strong>Username:</strong> <span id="profileUsername"></span></p>
            <p><strong>User ID:</strong> <span id="profileUserId"></span></p>
            <p><strong>Equipped Title:</strong> <span id="profileEquippedTitle"></span></p>
            <p><strong>Tokens:</strong> <span id="profileTokens"></span></p>
        </div>

        <h3>Overall Stats</h3>
        <div class="profile-stats-grid">
            <div class="stat-card">
                <h4>ELO Rating</h4>
                <p id="profileElo"></p>
            </div>
            <div class="stat-card">
                <h4>Casual Points</h4>
                <p id="profileCasualPoints"></p>
            </div>
            <div class="stat-card">
                <h4>Ranked Accuracy</h4>
                <p id="profileRankedAccuracy"></p>
            </div>
            <div class="stat-card">
                <h4>Casual Accuracy</h4>
                <p id="profileCasualAccuracy"></p>
            </div>
            <div class="stat-card">
                <h4>Solo Challenge Progress</h4>
                <p id="profileSoloStage"></p>
            </div>
        </div>

        <div class="profile-inventory">
            <h3>Your Inventory</h3>
            <div id="inventoryGrid" class="inventory-grid">
            
            </div>
        </div>

        <div class="button-group">
            <button class="secondary-btn" id="backFromProfileBtn">Back to Modes</button>
        </div>
    </section>



    <div id="customModalOverlay" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-btn" id="modalCloseBtn">&times;</button>
            <h3 id="modalTitle"></h3>
            <p id="modalMessage"></p>
            <div class="button-group" id="modalButtonGroup">
                <button class="primary-btn" id="modalConfirmBtn">OK</button>
                <button class="secondary-btn" id="modalCancelBtn">Cancel</button>
            </div>
        </div>
    </div>


    <div id="createLobbyModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-btn" id="createLobbyModalCloseBtn">&times;</button>
            <h3>Create New Lobby</h3>
            <div class="form-group">
                <label for="newLobbyNameInput">Lobby Name:</label>
                <input type="text" id="newLobbyNameInput" placeholder="Enter lobby name"/>
            </div>
            <div class="form-group">
                <label for="newLobbyMaxPlayersSelect">Max Players:</label>
                <select id="newLobbyMaxPlayersSelect">
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                </select>
            </div>
            <div class="form-group">
                <label for="initialLivesSelect">Initial Lives:</label>
                <select id="initialLivesSelect">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="5">5</option>
                </select>
            </div>
            <div class="form-group">
                <label for="questionTimerSelect">Question Timer (seconds):</label>
                <select id="questionTimerSelect">
                    <option value="10">10</option>
                    <option value="20">20</option>
                    <option value="30" selected>30</option>
                    <option value="45">45</option>
                    <option value="60">60</option>
                </select>
            </div>
            <div class="form-group checkbox-label">
                <label for="frenzyModeToggle">Frenzy Mode (Start with 3 random cards):</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="frenzyModeToggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <div class="button-group">
                <button class="primary-btn" id="confirmCreateLobbyBtn">Create Lobby</button>
                <button class="secondary-btn" id="cancelCreateLobbyBtn">Cancel</button>
            </div>
        </div>
    </div>


    <div id="codeInputModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-btn" id="codeInputModalCloseBtn">&times;</button>
            <h3>Redeem Code</h3>
            <div class="form-group">
                <label for="codeInput">Enter Code:</label>
                <input type="text" id="codeInput" placeholder="Enter your secret code"/>
            </div>
            <div class="button-group">
                <button class="primary-btn" id="redeemCodeBtn">Redeem</button>
                <button class="secondary-btn" id="cancelCodeInputBtn">Cancel</button>
            </div>
        </div>
    </div>

    <div id="floatingChat" class="floating-chat hidden">
        <div id="floatingChatHeader" class="chat-header">
            <span>Chat</span>
            <button id="toggleStickerPanelBtn" title="Toggle Stickers"><i class="far fa-smile"></i></button>
        </div>
        <div id="chatContent" class="chat-content">
        </div>
        <div id="stickerPanel" class="sticker-panel">
        </div>
        <div class="chat-input-area">
            <input type="text" id="chatInput4v4" placeholder="Type message..." autocomplete="off"/>
            <button id="sendChatBtn4v4">Send</button>
        </div>
    </div>


<script>
    
    const BACKEND_URL = "https://code-rivals-b3hd.onrender.com"; 
    const socket = io(BACKEND_URL); 
    let currentUser = null; 
    let userToken = null; 

  
    const usernameInput = document.getElementById('usernameInput');
    const passwordInput = document.getElementById('passwordInput');
    const authActionBtn = document.getElementById('authActionBtn');
    const authToggleText = document.getElementById('authToggleText');
    const toggleAuthModeLink = document.getElementById('toggleAuthMode');
    const welcomeMessage = document.getElementById('welcomeMessage');
    const logoutBtn = document.getElementById('logoutBtn');
    const profileIcon = document.getElementById('profileIcon');
    const inventoryIcon = document.getElementById('inventoryIcon');
    const shopIcon = document.getElementById('shopIcon');
    const codeInputIcon = document.getElementById('codeInputIcon');

    const gameModeSelection = document.getElementById('gameModeSelection');
    const freeForAllQnABtn = document.getElementById('freeForAllQnABtn');
    const oneVOneFillInBlanksBtn = document.getElementById('oneVOneFillInBlanksBtn');
    const soloCodingChallengeBtn = document.getElementById('soloCodingChallengeBtn');
    const rankedFreeForAllQnABtn = document.getElementById('rankedFreeForAllQnABtn');
    const rankedOneVOneFillInBlanksBtn = document.getElementById('rankedOneVOneFillInBlanksBtn');
    const customGameBtn = document.getElementById('customGameBtn');
    const globalLeaderboardBtn = document.getElementById('globalLeaderboardBtn');

    const lobbyListContainer = document.getElementById('lobbyListContainer');
    const lobbyListTitle = document.getElementById('lobbyListTitle');
    const createLobbyBtn = document.getElementById('createLobbyBtn');
    const backToGameModesBtn = document.getElementById('backToGameModesBtn');
    const lobbiesGrid = document.getElementById('lobbiesGrid');

    const singleLobbyView = document.getElementById('singleLobbyView');
    const currentLobbyTitle = document.getElementById('currentLobbyTitle');
    const displayLobbyId = document.getElementById('displayLobbyId');
    const displayPlayerCount = document.getElementById('displayPlayerCount');
    const displayMaxPlayers = document.getElementById('displayMaxPlayers');
    const displayLobbyStatus = document.getElementById('displayLobbyStatus');
    const lobbyPlayersDiv = document.getElementById('lobbyPlayers');
    const readyBtn = document.getElementById('readyBtn');
    const startGameBtn = document.getElementById('startGameBtn');
    const leaveLobbyBtn = document.getElementById('leaveLobbyBtn');

    const gameUI4v4 = document.getElementById('gameUI4v4');
    const gameTimerDisplay4v4 = document.getElementById('gameTimerDisplay4v4');
    const questionBox4v4 = document.getElementById('questionBox4v4');
    const currentQuestion4v4 = document.getElementById('currentQuestion4v4');
    const currentHint4v4 = document.getElementById('currentHint4v4');
    const playerCircleDiv4v4 = document.getElementById('playerCircleDiv4v4');
    const answerInput4v4 = document.getElementById('answerInput4v4');
    const submitAnswerBtn4v4 = document.getElementById('submitAnswerBtn4v4');
    const leaveGameBtn4v4 = document.getElementById('leaveGameBtn4v4');
    const playerCardsContainer4v4 = document.getElementById('playerCardsContainer4v4');

    const gameUI1v1 = document.getElementById('gameUI1v1');
    const gameTimerDisplay1v1 = document.getElementById('gameTimerDisplay1v1');
    const player1Name = document.getElementById('player1Name');
    const player1Lives = document.getElementById('player1Lives');
    const player1Score = document.getElementById('player1Score');
    const questionBox1v1Player1 = document.getElementById('questionBox1v1Player1');
    const currentQuestion1v1Player1 = document.getElementById('currentQuestion1v1Player1');
    const currentHint1v1Player1 = document.getElementById('currentHint1v1Player1');
    const answerInput1v1Player1 = document.getElementById('answerInput1v1Player1');
    const submitAnswerBtn1v1Player1 = document.getElementById('submitAnswerBtn1v1Player1');
    const player2Name = document.getElementById('player2Name');
    const player2Lives = document.getElementById('player2Lives');
    const player2Score = document.getElementById('player2Score');
    const questionBox1v1Player2 = document.getElementById('questionBox1v1Player2');
    const leaveGameBtn1v1 = document.getElementById('leaveGameBtn1v1');
    const playerCardsContainer1v1 = document.getElementById('playerCardsContainer1v1');

    const soloChallengeUI = document.getElementById('soloChallengeUI');
    const soloStageDisplay = document.getElementById('soloStageDisplay');
    const soloProblemText = document.getElementById('soloProblemText');
    const soloExpectedOutput = document.getElementById('soloExpectedOutput');
    const soloCodeEditor = document.getElementById('soloCodeEditor');
    const soloLoadingIndicator = document.getElementById('soloLoadingIndicator');
    const soloResult = document.getElementById('soloResult');
    const runCodeBtn = document.getElementById('runCodeBtn');
    const soloNextStageBtn = document.getElementById('soloNextStageBtn');
    const soloBackToModesBtn = document.getElementById('soloBackToModesBtn');

    const globalLeaderboard = document.getElementById('globalLeaderboard');
    const globalLeaderboardBody = document.getElementById('globalLeaderboardBody');
    const backFromLeaderboardBtn = document.getElementById('backFromLeaderboardBtn');

    const shopContainer = document.getElementById('shopContainer');
    const shopCurrentTokens = document.getElementById('shopCurrentTokens');
    const showAllItemsBtn = document.getElementById('showAllItemsBtn');
    const showTitlesBtn = document.getElementById('showTitlesBtn');
    const showAbilitiesBtn = document.getElementById('showAbilitiesBtn');
    const shopItemsGrid = document.getElementById('shopItemsGrid');
    const backFromShopBtn = document.getElementById('backFromShopBtn');

    const profilePage = document.getElementById('profilePage');
    const profileUsername = document.getElementById('profileUsername');
    const profileUserId = document.getElementById('profileUserId');
    const profileEquippedTitle = document.getElementById('profileEquippedTitle');
    const profileTokens = document.getElementById('profileTokens');
    const profileElo = document.getElementById('profileElo');
    const profileCasualPoints = document.getElementById('profileCasualPoints');
    const profileRankedAccuracy = document = document.getElementById('profileRankedAccuracy');
    const profileCasualAccuracy = document = document.getElementById('profileCasualAccuracy');
    const profileSoloStage = document.getElementById('profileSoloStage');
    const inventoryGrid = document.getElementById('inventoryGrid');
    const backFromProfileBtn = document.getElementById('backFromProfileBtn');


    // Modals
    const customModalOverlay = document.getElementById('customModalOverlay');
    const modalTitle = document.getElementById('modalTitle');
    const modalMessage = document.getElementById('modalMessage');
    const modalButtonGroup = document.getElementById('modalButtonGroup');
    const modalConfirmBtn = document.getElementById('modalConfirmBtn');
    const modalCancelBtn = document.getElementById('modalCancelBtn');
    const modalCloseBtn = document.getElementById('modalCloseBtn');

    const createLobbyModal = document.getElementById('createLobbyModal');
    const createLobbyModalCloseBtn = document.getElementById('createLobbyModalCloseBtn');
    const newLobbyNameInput = document.getElementById('newLobbyNameInput');
    const newLobbyMaxPlayersSelect = document.getElementById('newLobbyMaxPlayersSelect');
    const initialLivesSelect = document.getElementById('initialLivesSelect');
    const questionTimerSelect = document.getElementById('questionTimerSelect');
    const frenzyModeToggle = document.getElementById('frenzyModeToggle');
    const confirmCreateLobbyBtn = document.getElementById('confirmCreateLobbyBtn');
    const cancelCreateLobbyBtn = document.getElementById('cancelCreateLobbyBtn');

    const codeInputModal = document.getElementById('codeInputModal');
    const codeInputModalCloseBtn = document.getElementById('codeInputModalCloseBtn');
    const codeInput = document.getElementById('codeInput');
    const redeemCodeBtn = document.getElementById('redeemCodeBtn');
    const cancelCodeInputBtn = document.getElementById('cancelCodeInputBtn');


    // Game State Variables
    let isLoginMode = true;
    let currentLobbyType = '';
    let currentLobbyId = '';
    let players = []; // Array of player objects in current lobby
    let isPlayerReady = false;
    let isRankedMatch = false;
    let isCustomMatch = false;
    let timer; // For game timer
    let timeLeft = 30; // Default time per question
    let currentQuestionIndex = 0;
    let currentPlayerIndex = 0;
    let isPageActive = true; // Track if the browser tab is active

    // Solo Challenge Data (client-side for now, can be moved to backend)
    const soloChallenges = [
        {
            stage: 1,
            problem: "Write a C++ program that prints 'Hello, World!' to the console.",
            expectedOutput: "Hello, World!"
        },
        {
            stage: 2,
            problem: "Write a C++ program that reads two integers from input and prints their sum.",
            expectedOutput: "Input: 5 3\nOutput: 8" // Example, actual input/output would be dynamic
        },
        {
            stage: 3,
            problem: "Write a C++ program that calculates the factorial of a given non-negative integer. Assume input will be between 0 and 10.",
            expectedOutput: "Input: 5\nOutput: 120"
        }
        // Add more stages
    ];
    let currentSoloStage = 0; // Tracks the current stage the user is on

    // Shop Items (client-side for now, ideally managed by backend)
    const shopItems = [
        { id: 'title_master_coder', name: 'Master Coder', price: 1000, category: 'title', description: 'A prestigious title for skilled programmers.' },
        { id: 'title_bug_hunter', name: 'Bug Hunter', price: 500, category: 'title', description: 'Show off your debugging prowess.' },
        { id: 'ability_double_points', name: 'Double Points', price: 200, category: 'ability', description: 'Earn double points on your next correct answer.' },
        { id: 'ability_shield', name: 'Shield', price: 150, category: 'ability', description: 'Block one incorrect answer without losing a life.' },
        { id: 'title_algo_architect', name: 'Algo Architect', price: 1200, category: 'title', description: 'For those who build elegant algorithms.' },
        { id: 'ability_hint', name: 'Hint', price: 75, category: 'ability', description: 'Get a small hint for the current question.' }
    ];
    let currentShopCategory = 'all';


    // Helper Functions
    function showSection(section) {
        const sections = [
            authContainer, gameModeSelection, lobbyListContainer, singleLobbyView,
            gameUI4v4, gameUI1v1, soloChallengeUI, globalLeaderboard, shopContainer,
            profilePage
        ];
        sections.forEach(s => s.classList.add('hidden'));
        section.classList.remove('hidden');

        // Control chat visibility based on the displayed section
        if (section === authContainer) {
            floatingChat.classList.add('hidden'); // Hide chat on auth page
        } else {
            floatingChat.classList.remove('hidden'); // Show chat on all other pages
        }
    }

    async function showCustomModal(title, message, showCancel = false) {
        return new Promise((resolve) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalConfirmBtn.onclick = () => {
                customModalOverlay.classList.add('hidden');
                resolve(true);
            };
            modalCancelBtn.onclick = () => {
                customModalOverlay.classList.add('hidden');
                resolve(false);
            };
            modalCloseBtn.onclick = () => {
                customModalOverlay.classList.add('hidden');
                resolve(false); // Treat closing as cancellation
            };

            if (showCancel) {
                modalCancelBtn.style.display = 'inline-block';
            } else {
                modalCancelBtn.style.display = 'none';
            }
            customModalOverlay.classList.remove('hidden');
        });
    }

    function closeCreateLobbyModal() {
        createLobbyModal.classList.add('hidden');
    }

    function openCreateLobbyModal() {
        createLobbyModal.classList.remove('hidden');
    }

    function closeCodeInputModal() {
        codeInputModal.classList.add('hidden');
    }

    function openCodeInputModal() {
        codeInputModal.classList.remove('hidden');
    }

    // Authentication Functions
    async function authAction() {
        const username = usernameInput.value.trim();
        const password = passwordInput.value.trim();

        if (!username || !password) {
            await showCustomModal("Error", "Username and password cannot be empty.");
            return;
        }

        const endpoint = isLoginMode ? '/api/auth/login' : '/api/auth/signup';

        try {
            const response = await fetch(`${BACKEND_URL}${endpoint}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });

            const data = await response.json();

            if (response.ok) {
                userToken = data.token;
                currentUser = data.user; // Backend sends back user object
                localStorage.setItem('userToken', userToken); // Store token
                localStorage.setItem('currentUser', JSON.stringify(currentUser)); // Store user data

                handleSuccessfulAuth();
            } else {
                await showCustomModal("Error", data.msg || "Authentication failed.");
            }
        } catch (error) {
            console.error("Auth error:", error);
            await showCustomModal("Error", "Network error or server unavailable.");
        }
    }

    function handleSuccessfulAuth() {
        welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
        welcomeMessage.style.display = 'block';
        logoutBtn.style.display = 'block';
        profileIcon.style.display = 'flex';
        inventoryIcon.style.display = 'flex';
        shopIcon.style.display = 'flex';
        codeInputIcon.style.display = 'flex';
        showSection(gameModeSelection); // Go to game mode selection after login
        updateGlobalLeaderboard(); // This will now fetch from backend
        checkAndApplyPenalty(); // Check penalty on login
    }

    async function logout() {
        const confirmed = await showCustomModal("Confirm Logout", "Are you sure you want to log out?", true);
        if (!confirmed) {
            return;
        }

        // Inform server that user is leaving any current game/lobby
        if (currentLobbyId) {
            socket.emit('userLeftGame'); // Inform server about leaving game context
            try {
                await fetch(`${BACKEND_URL}/api/lobbies/${currentLobbyId}/leave`, {
                    method: 'POST',
                    headers: { 'x-auth-token': userToken }
                });
            } catch (error) {
                console.error("Error leaving lobby on logout:", error);
            }
        }

        currentUser = null;
        userToken = null;
        localStorage.removeItem('userToken');
        localStorage.removeItem('currentUser');
        if (timer) clearInterval(timer);

        showSection(authContainer); // This will now hide the chat
        logoutBtn.style.display = 'none';
        profileIcon.style.display = 'none';
        inventoryIcon.style.display = 'none';
        shopIcon.style.display = 'none';
        codeInputIcon.style.display = 'none';
        welcomeMessage.style.display = 'none';
        usernameInput.value = '';
        passwordInput.value = '';
        await showCustomModal("Logged Out", "You have been successfully logged out.");

        // Reset game-specific states
        players = [];
        currentLobbyType = '';
        currentLobbyId = '';
        isPlayerReady = false;
        isRankedMatch = false;
        isCustomMatch = false;
        currentQuestionIndex = 0;
        currentPlayerIndex = 0;
        timeLeft = 30;
        currentSoloStage = 0;
        updateGlobalLeaderboard(); // Refresh global leaderboard
    }

    // Lobby Management Functions
    async function createNewLobby() {
        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to create a lobby.");
            return;
        }
        if (isPenalized()) {
            await showCustomModal("Penalty Active", "You are currently penalized and cannot create a lobby.");
            return;
        }
        openCreateLobbyModal();
    }

    async function confirmCreateLobby() {
        const lobbyName = newLobbyNameInput.value.trim();
        const maxPlayers = parseInt(newLobbyMaxPlayersSelect.value);
        const isFrenzyMode = frenzyModeToggle.checked;
        const initialLives = parseInt(initialLivesSelect.value);
        const questionTimerValue = parseInt(questionTimerSelect.value);

        if (!lobbyName) {
            await showCustomModal("Error", "Lobby name cannot be empty.");
            return;
        }
        if (isPenalized()) {
            await showCustomModal("Penalty Active", "You are currently penalized and cannot create a lobby.");
            return;
        }

        try {
            const response = await fetch(`${BACKEND_URL}/api/lobbies`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-auth-token': userToken
                },
                body: JSON.stringify({
                    name: lobbyName,
                    maxPlayers,
                    type: currentLobbyType,
                    isFrenzyMode,
                    initialLives,
                    questionTimer: questionTimerValue
                })
            });

            const data = await response.json();

            if (response.ok) {
                closeCreateLobbyModal();
                await joinLobby(data.lobbyId); // Join the newly created lobby
            } else {
                await showCustomModal("Error", data.msg || "Failed to create lobby.");
            }
        } catch (error) {
            console.error("Error creating lobby:", error);
            await showCustomModal("Error", "Network error or server unavailable.");
        }
    }

    async function showLobbyList(type) {
        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to view lobbies.");
            return;
        }
        if (isPenalized()) {
            await showCustomModal("Penalty Active", "You are currently penalized and cannot join lobbies.");
            return;
        }

        currentLobbyType = type;
        isRankedMatch = false; // Only ranked modes set this to true
        isCustomMatch = type.startsWith('custom-');

        showSection(lobbyListContainer); // This will now show the chat
        if (type === 'free-for-all-qna') {
            lobbyListTitle.textContent = 'Available Free for All Q&A Lobbies';
        } else if (type === '1v1-fill-in-blanks') {
            lobbyListTitle.textContent = 'Available 1v1 Fill in the Blanks Lobbies';
        } else if (type === 'custom-qna') {
            lobbyListTitle.textContent = 'Available Custom Q&A Lobbies';
        } else if (type === 'custom-fill-in-blanks') {
            lobbyListTitle.textContent = 'Available Custom 1v1 Fill in the Blanks Lobbies';
        } else if (type === 'ranked-free-for-all-qna') {
            lobbyListTitle.textContent = 'Available Ranked Free for All Q&A Lobbies';
            isRankedMatch = true;
        } else if (type === 'ranked-1v1-fill-in-blanks') {
            lobbyListTitle.textContent = 'Available Ranked 1v1 Fill in the Blanks Lobbies';
            isRankedMatch = true;
        }
        await renderLobbies(); // Fetch and render
    }

    async function joinLobby(lobbyIdToJoin) {
        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to join a lobby.");
            return;
        }
        if (isPenalized()) {
            await showCustomModal("Penalty Active", "You are currently penalized and cannot join a lobby.");
            return;
        }

        try {
            const response = await fetch(`${BACKEND_URL}/api/lobbies/${lobbyIdToJoin}/join`, {
                method: 'POST',
                headers: { 'x-auth-token': userToken }
            });
            const data = await response.json();

            if (response.ok) {
                currentLobbyId = data.lobbyId;
                isRankedMatch = data.isRanked;
                isCustomMatch = data.isCustom;
                players = data.players; // Get players from backend
                isPlayerReady = data.players.find(p => p.id === currentUser.id)?.isReady || false;

                showSection(singleLobbyView); // This will now show the chat
                currentLobbyTitle.textContent = `Lobby: ${data.name}`;
                displayLobbyId.textContent = currentLobbyId;
                displayPlayerCount.textContent = players.length;
                displayMaxPlayers.textContent = data.maxPlayers;
                displayLobbyStatus.textContent = data.gameStarted ? 'In Game' : 'Waiting';

                updateReadyButtonState();
                renderLobbyPlayers();
                updateStartGameButtonState();

                // Join Socket.IO room for this lobby
                socket.emit('joinLobbyRoom', currentLobbyId);
                socket.emit('userEnteredGame', currentUser.id); // Inform server user is in game context

                // Render chat messages
                renderChatMessages(data.chatMessages); // Always render chat messages if in a lobby
            } else {
                await showCustomModal("Error", data.msg || "Failed to join lobby.");
                currentLobbyId = '';
            }
        } catch (error) {
            console.error("Error joining lobby:", error);
            await showCustomModal("Error", "Network error or server unavailable.");
        }
    }

    async function leaveLobby() {
        if (!currentLobbyId || !currentUser) return;

        const confirmed = await showCustomModal("Confirm Leave", "Are you sure you want to leave this lobby?", true);
        if (!confirmed) return;

        try {
            const response = await fetch(`${BACKEND_URL}/api/lobbies/${currentLobbyId}/leave`, {
                method: 'POST',
                headers: { 'x-auth-token': userToken }
            });
            const data = await response.json();

            if (response.ok) {
                socket.emit('leaveLobbyRoom', currentLobbyId); // Leave Socket.IO room
                socket.emit('userLeftGame'); // Inform server user left game context
                leaveLobbyStateCleanUp();
                await showCustomModal("Lobby Left", data.msg || "You have left the lobby.");
            } else {
                await showCustomModal("Error", data.msg || "Failed to leave lobby.");
            }
        } catch (error) {
            console.error("Error leaving lobby:", error);
            await showCustomModal("Error", "Network error or server unavailable.");
        }
    }

    function leaveLobbyStateCleanUp() {
        currentLobbyId = '';
        isRankedMatch = false;
        isCustomMatch = false;
        players = [];
        isPlayerReady = false;
        showSection(gameModeSelection); // Go back to game modes, this will hide the chat
    }

    function renderLobbyPlayers() {
        lobbyPlayersDiv.innerHTML = '';
        players.forEach(player => {
            const playerCard = document.createElement('div');
            playerCard.className = `player-card ${player.isReady ? 'ready' : ''}`;
            playerCard.innerHTML = `
                <h4>${player.name}</h4>
                <p>Status: ${player.isReady ? 'Ready' : 'Not Ready'}</p>
                <p>ELO: ${player.elo}</p>
            `;
            lobbyPlayersDiv.appendChild(playerCard);
        });
    }

    function updateReadyButtonState() {
        if (isRankedMatch) {
            readyBtn.style.display = 'none'; // No ready button for ranked
        } else {
            readyBtn.style.display = 'inline-block';
            readyBtn.textContent = isPlayerReady ? 'Unready' : 'Ready';
            readyBtn.classList.toggle('secondary-btn', isPlayerReady);
            readyBtn.classList.toggle('primary-btn', !isPlayerReady);
            readyBtn.disabled = isPenalized();
        }
    }

    function updateStartGameButtonState() {
        const allPlayersReady = players.every(p => p.isReady);
        startGameBtn.disabled = !allPlayersReady || players.length < 2 || isPenalized() || currentUser.id !== players.find(p => p.type === 'human')?.id; // Only host can start
        if (currentUser.id !== players.find(p => p.type === 'human')?.id) {
            startGameBtn.textContent = 'Only Host Can Start';
        } else if (!allPlayersReady) {
            startGameBtn.textContent = 'Waiting for Players';
        } else {
            startGameBtn.textContent = 'Start Game';
        }
    }

    async function toggleReady() {
        if (!currentLobbyId || !currentUser) {
            await showCustomModal("Error", "Not in a lobby or not logged in.");
            return;
        }
        if (isPenalized()) {
            await showCustomModal("Penalty Active", "You are currently penalized and cannot change ready status.");
            return;
        }

        try {
            const response = await fetch(`${BACKEND_URL}/api/lobbies/${currentLobbyId}/ready`, {
                method: 'POST',
                headers: { 'x-auth-token': userToken }
            });
            const data = await response.json();

            if (!response.ok) {
                await showCustomModal("Error", data.msg || "Failed to toggle ready status.");
            }
            // Lobby update will be received via Socket.IO
        } catch (error) {
            console.error("Error toggling ready:", error);
            await showCustomModal("Error", "Network error or server unavailable.");
        }
    }

    async function startGame() {
        if (!currentLobbyId || !currentUser) {
            await showCustomModal("Error", "Not in a lobby or not logged in.");
            return;
        }
        if (isPenalized()) {
            await showCustomModal("Penalty Active", "You are currently penalized and cannot start a game.");
            return;
        }

        const confirmed = await showCustomModal("Confirm Game Start", "Are you sure you want to start the game?", true);
        if (!confirmed) return;

        try {
            const response = await fetch(`${BACKEND_URL}/api/lobbies/${currentLobbyId}/start`, {
                method: 'POST',
                headers: { 'x-auth-token': userToken }
            });
            const data = await response.json();

            if (response.ok) {
                await showCustomModal("Game Started!", "The game is commencing!");
                // Game state will be updated via Socket.IO 'gameStarted' event
            } else {
                await showCustomModal("Error", data.msg || "Failed to start game.");
            }
        } catch (error) {
            console.error("Error starting game:", error);
            await showCustomModal("Error", "Network error or server unavailable.");
        }
    }

    function startGameUI(gameType) {
        showSection(gameType.includes('qna') ? gameUI4v4 : gameUI1v1); // This will now show the chat
        updateGameUI();
        startTimer();
    }

    function updateGameUI() {
        const currentLobby = players; // Use the 'players' array which is updated by socket.io
        if (!currentLobby || currentLobby.length === 0) return;

        const currentPlayer = currentLobby[currentPlayerIndex];
        const currentQuestion = activeLobbies[currentLobbyId].questions[currentQuestionIndex]; // Get questions from cached lobby

        // Update common elements
        if (currentLobbyType.includes('qna')) {
            currentQuestion4v4.textContent = currentQuestion.q;
            currentHint4v4.textContent = currentQuestion.hint || '';
            currentHint4v4.style.display = currentQuestion.hint ? 'block' : 'none';
            playerCircleDiv4v4.innerHTML = ''; // Clear previous circles
            currentLobby.forEach((p, index) => {
                const circle = document.createElement('div');
                circle.className = `player-circle ${index === currentPlayerIndex ? 'current-turn' : ''} ${p.lives <= 0 ? 'eliminated' : ''}`;
                circle.innerHTML = `
                    <span>${p.name}</span>
                    <span>Score: ${p.currentRoundScore}</span>
                    <div class="lives-indicator">${p.lives}</div>
                    ${p.shields > 0 ? `<div class="shields-indicator">${p.shields}</div>` : ''}
                `;
                playerCircleDiv4v4.appendChild(circle);
            });
            gameTimerDisplay4v4.textContent = timeLeft;
            answerInput4v4.value = '';
            answerInput4v4.disabled = false;
            submitAnswerBtn4v4.style.display = 'block';
        } else if (currentLobbyType.includes('fill-in-blanks')) {
            player1Name.textContent = currentUser.username;
            player1Lives.textContent = players.find(p => p.id === currentUser.id)?.lives || 0;
            player1Score.textContent = players.find(p => p.id === currentUser.id)?.currentRoundScore || 0;

            player2Name.textContent = players.find(p => p.id !== currentUser.id)?.name || 'Opponent';
            player2Lives.textContent = players.find(p => p.id !== currentUser.id)?.lives || 0;
            player2Score.textContent = players.find(p => p.id !== currentUser.id)?.currentRoundScore || 0;

            currentQuestion1v1Player1.textContent = currentQuestion.q;
            currentHint1v1Player1.textContent = currentQuestion.hint || '';
            currentHint1v1Player1.style.display = currentQuestion.hint ? 'block' : 'none';
            questionBox1v1Player2.textContent = currentQuestion.q; // Opponent also sees same question

            gameTimerDisplay1v1.textContent = timeLeft;
            answerInput1v1Player1.value = '';
            answerInput1v1Player1.disabled = false;
            submitAnswerBtn1v1Player1.style.display = 'block';
        }

        // Update ability cards for the current user
        const userPlayer = players.find(p => p.id === currentUser.id);
        if (userPlayer) {
            const cardsContainer = currentLobbyType.includes('qna') ? playerCardsContainer4v4 : playerCardsContainer1v1;
            cardsContainer.innerHTML = '';
            if (userPlayer.cards && userPlayer.cards.length > 0) {
                userPlayer.cards.forEach(card => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'player-card-item';
                    const fullCardInfo = shopItems.find(item => item.id === card.id); // Assuming shopItems has card details
                    cardDiv.innerHTML = `
                        <span class="card-name">${card.name}</span>
                        <span class="card-description">${fullCardInfo ? fullCardInfo.description : ''}</span>
                    `;
                    // Add click listener for card usage (this would trigger a backend action)
                    cardDiv.addEventListener('click', () => useAbilityCard(card.id));
                    cardsContainer.appendChild(cardDiv);
                });
            } else {
                cardsContainer.innerHTML = '<p style="font-size:0.8em; color:#aaa; text-align:center;">No ability cards.</p>';
            }
        }
    }

    function startTimer() {
        if (timer) clearInterval(timer);
        timeLeft = activeLobbies[currentLobbyId].questionTimer; // Use lobby's set timer
        const timerDisplay = currentLobbyType.includes('qna') ? gameTimerDisplay4v4 : gameTimerDisplay1v1;
        timerDisplay.textContent = timeLeft;

        timer = setInterval(() => {
            timeLeft--;
            timerDisplay.textContent = timeLeft;
            if (timeLeft <= 0) {
                clearInterval(timer);
                // Auto-submit or penalize if time runs out
                // For now, just clear input and wait for server update
                if (currentLobbyType.includes('qna')) {
                    answerInput4v4.value = '';
                    answerInput4v4.disabled = true;
                    submitAnswerBtn4v4.style.display = 'none';
                } else if (currentLobbyType.includes('fill-in-blanks')) {
                    answerInput1v1Player1.value = '';
                    answerInput1v1Player1.disabled = true;
                    submitAnswerBtn1v1Player1.style.display = 'none';
                }
                // The server will handle the turn progression and penalties for timeout
            }
        }, 1000);
    }

    async function submitAnswer() {
        clearInterval(timer); // Stop timer immediately

        let answerInput;
        if (currentLobbyType.includes('qna')) {
            answerInput = answerInput4v4;
            answerInput4v4.disabled = true;
            submitAnswerBtn4v4.style.display = 'none';
        } else if (currentLobbyType.includes('fill-in-blanks')) {
            answerInput = answerInput1v1Player1;
            answerInput1v1Player1.disabled = true;
            submitAnswerBtn1v1Player1.style.display = 'none';
        } else {
            return;
        }

        const userAnswer = answerInput.value.trim();

        try {
            const response = await fetch(`${BACKEND_URL}/api/lobbies/${currentLobbyId}/answer`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-auth-token': userToken
                },
                body: JSON.stringify({ userAnswer })
            });
            const data = await response.json();

            if (!response.ok) {
                await showCustomModal("Error", data.msg || "Failed to submit answer.");
            }
            // Game state update will be received via Socket.IO 'lobbyUpdated' or 'gameEnded' events
        } catch (error) {
            console.error("Error submitting answer:", error);
            await showCustomModal("Error", "Network error or server unavailable.");
        }
        answerInput.value = ''; // Clear input for next question
    }

    async function leaveGame(isPenaltyExit = false) {
        let confirmed = true;
        if (!isPenaltyExit) {
            confirmed = await showCustomModal("Confirm Exit Game", "Are you sure you want to exit the current game and return to lobbies? No tokens will be awarded for an incomplete game.", true);
        }
        if (!confirmed) return;

        if (timer) clearInterval(timer);
        socket.emit('userLeftGame'); // Inform server about leaving game context

        // No need to send leave lobby request to backend here, as penalty system or game end will handle it.
        // If user manually leaves in the middle of a game, they just stop receiving updates.
        // The server will eventually detect inactivity or the game will end.

        // Reset UI elements
        gameTimerDisplay4v4.textContent = '30';
        answerInput4v4.value = '';
        answerInput4v4.disabled = false;
        submitAnswerBtn4v4.style.display = 'block';
        // replayButton.style.display = 'none'; // Replay button is not defined in this scope
        playerCircleDiv4v4.innerHTML = '';
        questionBox1v1Player1.style.display = 'none';
        questionBox1v1Player2.style.display = 'none';
        playerCardsContainer4v4.innerHTML = '';
        playerCardsContainer1v1.innerHTML = '';

        // Go back to single lobby view, which will be updated by server's lobbyUpdated event
        // Or go back to mode selection if lobby was deleted
        showSection(gameModeSelection); // Always go back to game mode selection, this will hide the chat
        currentLobbyType = '';
        currentLobbyId = '';
        isPlayerReady = false;
        isRankedMatch = false;
        isCustomMatch = false;
        players = [];
    }

    async function useAbilityCard(cardId) {
        await showCustomModal("Ability Card", `You used the card: ${cardId}. (This would trigger backend logic to apply card effect)`);
        // In a real implementation, you'd send a request to the backend:
        /*
        try {
            const response = await fetch(`${BACKEND_URL}/api/lobbies/${currentLobbyId}/use-card`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-auth-token': userToken
                },
                body: JSON.stringify({ cardId })
            });
            const data = await response.json();
            if (!response.ok) {
                await showCustomModal("Error", data.msg || "Failed to use card.");
            }
            // Backend would then emit lobbyUpdated to reflect card usage
        } catch (error) {
            console.error("Error using card:", error);
            await showCustomModal("Error", "Network error or server unavailable.");
        }
        */
    }

    // Solo Challenge Functions
    function loadSoloChallenge() {
        if (!currentUser) {
            showCustomModal("Error", "You must be logged in to play solo challenges.");
            return;
        }
        currentSoloStage = currentUser.soloStage || 0; // Get current solo stage from user data
        if (currentSoloStage >= soloChallenges.length) {
            soloStageDisplay.textContent = `Completed All Stages!`;
            soloProblemText.textContent = `Congratulations! You have completed all available solo coding challenges.`;
            soloExpectedOutput.textContent = ``;
            soloCodeEditor.value = `// All challenges completed!`;
            soloCodeEditor.disabled = true;
            runCodeBtn.disabled = true;
            soloNextStageBtn.disabled = true;
            return;
        }

        const stage = soloChallenges[currentSoloStage];
        soloStageDisplay.textContent = currentSoloStage + 1;
        soloProblemText.textContent = stage.problem;
        soloExpectedOutput.textContent = stage.expectedOutput;
        soloCodeEditor.value = `// Write your C++ code for Stage ${currentSoloStage + 1} here\n\n#include <iostream>\n\nint main() {\n    // Your code here\n    return 0;\n}`;
        soloResult.textContent = '';
        soloLoadingIndicator.style.display = 'none';
        runCodeBtn.disabled = isPenalized();
        soloCodeEditor.disabled = false;
        soloNextStageBtn.disabled = (currentUser.soloStage <= currentSoloStage || currentSoloStage >= soloChallenges.length - 1);
        showSection(soloChallengeUI); // This will now show the chat
    }

    async function submitSoloCode() {
        const code = soloCodeEditor.value;
        const stageData = soloChallenges[currentSoloStage];

        if (!stageData) {
            await showCustomModal("Error", "No solo challenge loaded.");
            return;
        }
        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to submit code.");
            return;
        }
        if (isPenalized()) {
            await showCustomModal("Penalty Active", "You are currently penalized and cannot submit code.");
            return;
        }

        soloResult.textContent = '';
        soloLoadingIndicator.style.display = 'block';
        runCodeBtn.disabled = true;
        soloCodeEditor.disabled = true;

        try {
            const response = await fetch(`${BACKEND_URL}/api/solo/evaluate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-auth-token': userToken
                },
                body: JSON.stringify({ code, stageData })
            });

            const data = await response.json();

            if (response.ok) {
                soloResult.textContent = data.evaluation;
                const isCorrect = data.isCorrect;
                const accuracyScore = data.accuracy;

                if (isCorrect) {
                    // Update current user's local soloStageAccuracy and other stats
                    // These will be updated on the server, and the next login will fetch fresh data.
                    // For immediate UI update, manually update currentUser object.
                    currentUser.soloStageAccuracy = { ...currentUser.soloStageAccuracy, [stageData.stage]: accuracyScore };
                    if (currentUser.soloStage === stageData.stage) {
                        currentUser.soloStage++;
                        currentUser.elo += 75;
                        currentUser.tokens += 50;
                    }
                    localStorage.setItem('currentUser', JSON.stringify(currentUser)); // Update local storage
                    welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;

                    await showCustomModal("Success", `Stage ${stageData.stage} Complete! Accuracy: ${accuracyScore}%`);
                    loadSoloChallenge(); // Load next stage
                } else {
                    await showCustomModal("Try Again", "Your code needs some adjustments. Check the evaluation for hints.");
                }
            } else {
                await showCustomModal("Evaluation Error", data.msg || "Failed to evaluate code.");
                soloResult.textContent = data.msg || "An error occurred during evaluation.";
            }

        } catch (error) {
            console.error("Error calling backend for solo evaluation:", error);
            soloResult.textContent = `An error occurred during evaluation: ${error.message}. Please try again.`;
            await showCustomModal("Evaluation Error", "Failed to evaluate code. Please check your internet connection and try again.");
        } finally {
            soloLoadingIndicator.style.display = 'none';
            runCodeBtn.disabled = isPenalized();
            soloCodeEditor.disabled = false;
            soloNextStageBtn.disabled = (currentUser.soloStage <= currentSoloStage || currentSoloStage >= soloChallenges.length - 1);
        }
    }

    function goToNextSoloStage() {
        currentSoloStage++;
        loadSoloChallenge();
    }

    // Global Leaderboard Functions
    async function updateGlobalLeaderboard() {
        globalLeaderboardBody.innerHTML = '';
        try {
            const response = await fetch(`${BACKEND_URL}/api/global-leaderboard`);
            const globalPlayers = await response.json();

            if (globalPlayers.length === 0) {
                const row = globalLeaderboardBody.insertRow();
                const cell = row.insertCell(0);
                cell.colSpan = 4;
                cell.textContent = 'No leaderboard data available.';
                cell.style.textAlign = 'center';
                return;
            }

            globalPlayers.forEach((player, index) => {
                const row = globalLeaderboardBody.insertRow();
                const rankedAccuracy = player.rankedTotalAnswers > 0 ? ((player.rankedCorrectAnswers / player.rankedTotalAnswers) * 100).toFixed(0) : 0;
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${player.username}</td>
                    <td>${player.elo}</td>
                    <td>${rankedAccuracy}%</td>
                `;
            });
        } catch (error) {
            console.error("Error fetching global leaderboard:", error);
            globalLeaderboardBody.innerHTML = '<tr><td colspan="4" style="color: red;">Failed to load leaderboard.</td></tr>';
        }
    }

    // Shop Functions
    function renderShopItems(category) {
        shopItemsGrid.innerHTML = '';
        shopCurrentTokens.textContent = currentUser ? currentUser.tokens : 0;

        const filteredItems = shopItems.filter(item => {
            if (category === 'all') return true;
            return item.category === category;
        });

        if (filteredItems.length === 0) {
            shopItemsGrid.innerHTML = '<p style="color: #ccc; text-align: center;">No items in this category.</p>';
            return;
        }

        filteredItems.forEach(item => {
            const itemCard = document.createElement('div');
            itemCard.className = 'shop-item-card';
            const ownsItem = currentUser && currentUser.inventory.includes(item.id);
            const canAfford = currentUser && currentUser.tokens >= item.price;
            const isDisabled = ownsItem || !canAfford;

            itemCard.innerHTML = `
                <h3>${item.name}</h3>
                <p>${item.description}</p>
                <p class="item-price">${item.price} Tokens</p>
                <button class="buy-btn primary-btn" data-item-id="${item.id}" ${isDisabled ? 'disabled' : ''}>
                    ${ownsItem ? 'Owned' : (canAfford ? 'Buy' : 'Not Enough Tokens')}
                </button>
            `;
            const buyBtn = itemCard.querySelector('.buy-btn');
            if (!isDisabled) {
                buyBtn.addEventListener('click', () => buyItem(item.id));
            }
            shopItemsGrid.appendChild(itemCard);
        });

        // Update category button active state
        document.querySelectorAll('.shop-categories button').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.category === category) {
                btn.classList.add('active');
            }
        });
    }

    async function buyItem(itemId) {
        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to buy items.");
            return;
        }

        const item = shopItems.find(i => i.id === itemId);
        if (!item) {
            await showCustomModal("Error", "Item not found.");
            return;
        }
        if (currentUser.inventory.includes(itemId)) {
            await showCustomModal("Error", "You already own this item.");
            return;
        }
        if (currentUser.tokens < item.price) {
            await showCustomModal("Error", "You do not have enough tokens.");
            return;
        }

        const confirmed = await showCustomModal("Confirm Purchase", `Are you sure you want to buy "${item.name}" for ${item.price} tokens?`, true);
        if (!confirmed) return;

        try {
            const response = await fetch(`${BACKEND_URL}/api/users/buy-item`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-auth-token': userToken
                },
                body: JSON.stringify({
                    itemId: item.id,
                    itemPrice: item.price,
                    itemCategory: item.category,
                    itemName: item.name
                })
            });

            const data = await response.json();

            if (response.ok) {
                currentUser.tokens = data.newTokens;
                currentUser.inventory = data.newInventory;
                if (data.newEquippedTitle) {
                    currentUser.equippedTitle = data.newEquippedTitle;
                }
                localStorage.setItem('currentUser', JSON.stringify(currentUser));

                await showCustomModal("Purchase Successful!", `You bought "${item.name}"! Remaining tokens: ${currentUser.tokens}`);
                shopCurrentTokens.textContent = currentUser.tokens;
                welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
                renderShopItems(currentShopCategory);
                updateProfilePage(); // Update profile page to reflect new inventory/title
            } else {
                await showCustomModal("Purchase Failed", data.msg || "Failed to complete purchase.");
            }
        } catch (error) {
            console.error("Error buying item:", error);
            await showCustomModal("Error", "Network error or server unavailable.");
        }
    }

    // Code Input / Redeem Code
    async function redeemCode() {
        const enteredCode = codeInput.value.trim();
        closeCodeInputModal();

        if (!currentUser) {
            await showCustomModal("Error", "You must be logged in to redeem codes.");
            return;
        }

        try {
            const response = await fetch(`${BACKEND_URL}/api/users/redeem-code`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-auth-token': userToken
                },
                body: JSON.stringify({ code: enteredCode })
            });

            const data = await response.json();

            if (response.ok) {
                currentUser.tokens = data.newTokens; // Update local tokens
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
                await showCustomModal("Code Redeemed!", `Congratulations! You received ${data.newTokens - (currentUser.tokens - data.newTokens)} tokens! Your new total: ${currentUser.tokens}`);
                welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
                shopCurrentTokens.textContent = currentUser.tokens; // Update shop tokens if open
                updateProfilePage(); // Update profile page to reflect new tokens
            } else {
                await showCustomModal("Invalid Code", data.msg || "The code you entered is not valid. Please try again.");
            }
        } catch (error) {
            console.error("Error redeeming code:", error);
            await showCustomModal("Error", "Network error or server unavailable.");
        }
    }

    // Penalty System
    function isPenalized() {
        if (!currentUser || !currentUser.penaltyEndTime) {
            return false;
        }
        return new Date() < new Date(currentUser.penaltyEndTime);
    }

    function updatePenaltyButtonStates() {
        const disabled = isPenalized();
        // Disable relevant buttons if penalized
        createLobbyBtn.disabled = disabled;
        freeForAllQnABtn.disabled = disabled;
        oneVOneFillInBlanksBtn.disabled = disabled;
        soloCodingChallengeBtn.disabled = disabled;
        rankedFreeForAllQnABtn.disabled = disabled;
        rankedOneVOneFillInBlanksBtn.disabled = disabled;
        customGameBtn.disabled = disabled;
        readyBtn.disabled = disabled;
        startGameBtn.disabled = disabled;
        runCodeBtn.disabled = disabled;
        // Also disable join buttons on lobby list (handled in renderLobbies)
    }

    function checkAndApplyPenalty() {
        if (currentUser && currentUser.penaltyEndTime) {
            const penaltyEnd = new Date(currentUser.penaltyEndTime);
            if (new Date() < penaltyEnd) {
                updatePenaltyButtonStates();
                const timeLeft = Math.ceil((penaltyEnd - new Date()) / 1000);
                // Only show modal if not already shown or if it's a new penalty
                if (!customModalOverlay.classList.contains('hidden') && modalTitle.textContent.includes("Penalty Active")) {
                    // Update existing modal message
                    modalMessage.textContent = `You are currently penalized. You cannot join or start a match for ${timeLeft} seconds.`;
                } else {
                    showCustomModal("Penalty Active", `You are currently penalized. You cannot join or start a match for ${timeLeft} seconds.`);
                }

                const penaltyCheckInterval = setInterval(() => {
                    if (!isPenalized()) {
                        clearInterval(penaltyCheckInterval);
                        // Clear penalty on client side once expired
                        currentUser.penaltyEndTime = null;
                        currentUser.warningCount = 0;
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                        updatePenaltyButtonStates();
                        showCustomModal("Penalty Over!", "Your penalty has ended. You can now join or start matches.");
                    } else {
                        const remainingTime = Math.ceil((new Date(currentUser.penaltyEndTime) - new Date()) / 1000);
                        if (!customModalOverlay.classList.contains('hidden') && modalTitle.textContent.includes("Penalty Active")) {
                            modalMessage.textContent = `You are currently penalized. You cannot join or start a match for ${remainingTime} seconds.`;
                        }
                    }
                }, 1000);
            } else {
                // Penalty has expired, clear it locally
                currentUser.penaltyEndTime = null;
                currentUser.warningCount = 0;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
                updatePenaltyButtonStates();
            }
        } else {
            updatePenaltyButtonStates();
        }
    }


    // Profile Page Functions
    function showProfilePage() {
        if (!currentUser) {
            showCustomModal("Error", "You must be logged in to view your profile.");
            return;
        }
        showSection(profilePage); // This will now show the chat
        updateProfilePage();
    }

    function updateProfilePage() {
        if (!currentUser) return;

        profileUsername.textContent = currentUser.username;
        profileUserId.textContent = currentUser.id;
        profileEquippedTitle.textContent = currentUser.equippedTitle || 'No Title Equipped';
        profileTokens.textContent = currentUser.tokens;
        profileElo.textContent = currentUser.elo;
        profileCasualPoints.textContent = currentUser.casualPoints;

        const rankedAccuracy = currentUser.rankedTotalAnswers > 0 ? ((currentUser.rankedCorrectAnswers / currentUser.rankedTotalAnswers) * 100).toFixed(0) : 0;
        profileRankedAccuracy.textContent = `${rankedAccuracy}% (${currentUser.rankedCorrectAnswers}/${currentUser.rankedTotalAnswers})`;

        const casualAccuracy = currentUser.casualTotalAnswers > 0 ? ((currentUser.casualCorrectAnswers / currentUser.casualTotalAnswers) * 100).toFixed(0) : 0;
        profileCasualAccuracy.textContent = `${casualAccuracy}% (${currentUser.casualCorrectAnswers}/${currentUser.casualTotalAnswers})`;

        profileSoloStage.textContent = `${currentUser.soloStage || 0} / ${soloChallenges.length}`;

        // Render inventory
        inventoryGrid.innerHTML = '';
        if (currentUser.inventory && currentUser.inventory.length > 0) {
            currentUser.inventory.forEach(itemId => {
                const item = shopItems.find(i => i.id === itemId);
                if (item) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `inventory-item ${currentUser.equippedTitle === item.name ? 'equipped' : ''}`;
                    itemDiv.textContent = item.name;
                    inventoryGrid.appendChild(itemDiv);
                }
            });
        } else {
            inventoryGrid.innerHTML = '<p style="color: #ccc; text-align: center; width: 100%;">Your inventory is empty.</p>';
        }
    }


    // Event Listeners
    authActionBtn.addEventListener('click', authAction);
    toggleAuthModeLink.addEventListener('click', (e) => {
        e.preventDefault();
        isLoginMode = !isLoginMode;
        authActionBtn.textContent = isLoginMode ? 'Login' : 'Sign Up';
        authToggleText.textContent = isLoginMode ? "Don't have an account?" : "Already have an account?";
        toggleAuthModeLink.textContent = isLoginMode ? 'Sign Up' : 'Login';
    });
    logoutBtn.addEventListener('click', logout);
    profileIcon.addEventListener('click', showProfilePage); // New event listener for profile icon
    backFromProfileBtn.addEventListener('click', () => showSection(gameModeSelection)); // Back from profile

    freeForAllQnABtn.addEventListener('click', () => showLobbyList('free-for-all-qna'));
    oneVOneFillInBlanksBtn.addEventListener('click', () => showLobbyList('1v1-fill-in-blanks'));
    soloCodingChallengeBtn.addEventListener('click', loadSoloChallenge);
    rankedFreeForAllQnABtn.addEventListener('click', () => showLobbyList('ranked-free-for-all-qna'));
    rankedOneVOneFillInBlanksBtn.addEventListener('click', () => showLobbyList('ranked-1v1-fill-in-blanks'));
    customGameBtn.addEventListener('click', () => showCustomGameCreation()); // Function to handle custom game creation flow
    globalLeaderboardBtn.addEventListener('click', () => { showSection(globalLeaderboard); updateGlobalLeaderboard(); }); // Show chat on leaderboard
    backFromLeaderboardBtn.addEventListener('click', () => showSection(gameModeSelection));

    createLobbyBtn.addEventListener('click', createNewLobby);
    confirmCreateLobbyBtn.addEventListener('click', confirmCreateLobby);
    cancelCreateLobbyBtn.addEventListener('click', closeCreateLobbyModal);
    createLobbyModalCloseBtn.addEventListener('click', closeCreateLobbyModal);
    backToGameModesBtn.addEventListener('click', () => showSection(gameModeSelection));

    readyBtn.addEventListener('click', toggleReady);
    startGameBtn.addEventListener('click', startGame);
    leaveLobbyBtn.addEventListener('click', leaveLobby);

    submitAnswerBtn4v4.addEventListener('click', submitAnswer);
    leaveGameBtn4v4.addEventListener('click', () => leaveGame(false));
    submitAnswerBtn1v1Player1.addEventListener('click', submitAnswer);
    leaveGameBtn1v1.addEventListener('click', () => leaveGame(false));

    runCodeBtn.addEventListener('click', submitSoloCode);
    soloNextStageBtn.addEventListener('click', goToNextSoloStage);
    soloBackToModesBtn.addEventListener('click', () => showSection(gameModeSelection));

    shopIcon.addEventListener('click', () => {
        if (!currentUser) {
            showCustomModal("Error", "You must be logged in to view the shop.");
            return;
        }
        showSection(shopContainer); // This will now show the chat
        currentShopCategory = 'all'; // Reset to all items when opening shop
        renderShopItems(currentShopCategory);
    });
    backFromShopBtn.addEventListener('click', () => showSection(gameModeSelection));
    showAllItemsBtn.addEventListener('click', () => { currentShopCategory = 'all'; renderShopItems('all'); });
    showTitlesBtn.addEventListener('click', () => { currentShopCategory = 'title'; renderShopItems('title'); });
    showAbilitiesBtn.addEventListener('click', () => { currentShopCategory = 'ability'; renderShopItems('ability'); });

    codeInputIcon.addEventListener('click', openCodeInputModal);
    redeemCodeBtn.addEventListener('click', redeemCode);
    cancelCodeInputBtn.addEventListener('click', closeCodeInputModal);
    codeInputModalCloseBtn.addEventListener('click', closeCodeInputModal);


    // Initial Load
    document.addEventListener('DOMContentLoaded', async () => {
        const storedToken = localStorage.getItem('userToken');
        const storedUser = localStorage.getItem('currentUser');

        if (storedToken && storedUser) {
            try {
                const response = await fetch(`${BACKEND_URL}/api/auth/user`, {
                    method: 'GET',
                    headers: { 'x-auth-token': storedToken }
                });
                const data = await response.json();
                if (response.ok) {
                    userToken = storedToken;
                    currentUser = data; // Get fresh user data from backend
                    handleSuccessfulAuth();
                } else {
                    console.error("Failed to re-authenticate:", data.msg);
                    localStorage.removeItem('userToken');
                    localStorage.removeItem('currentUser');
                    showSection(authContainer); // This will hide the chat
                }
            } catch (error) {
                console.error("Network error during re-authentication:", error);
                localStorage.removeItem('userToken');
                localStorage.removeItem('currentUser');
                showSection(authContainer); // This will hide the chat
            }
        } else {
            showSection(authContainer); // This will hide the chat
        }
        // Request global leaderboard data on load
        updateGlobalLeaderboard();
    });

    // Socket.IO Event Listeners
    socket.on('connect', () => {
        console.log('Connected to Socket.IO server');
        if (currentLobbyId) {
            socket.emit('joinLobbyRoom', currentLobbyId); // Rejoin lobby room on reconnect
        }
    });

    socket.on('disconnect', () => {
        console.log('Disconnected from Socket.IO server');
    });

    socket.on('lobbyCreated', (newlyCreatedLobby) => {
        // If you are on the lobby list page, refresh it
        if (lobbyListContainer.style.display === 'flex' && newlyCreatedLobby.type === currentLobbyType && !newlyCreatedLobby.isRanked) {
            renderLobbies(); // Re-fetch and render lobbies
        }
    });

    // Cache for lobby settings (e.g., questionTimer, isFrenzyMode)
    const activeLobbies = {};

    socket.on('lobbyUpdated', (updatedLobby) => {
        // Only update if it's the lobby the current user is in
        if (updatedLobby.lobbyId === currentLobbyId) {
            players = updatedLobby.players; // Update local players array
            isPlayerReady = updatedLobby.players.find(p => p.id === currentUser.id)?.isReady || false;
            activeLobbies[currentLobbyId] = updatedLobby; // Update cached lobby for settings

            displayPlayerCount.textContent = players.length;
            displayMaxPlayers.textContent = updatedLobby.maxPlayers;
            displayLobbyStatus.textContent = updatedLobby.gameStarted ? 'In Game' : 'Waiting';

            updateReadyButtonState();
            renderLobbyPlayers();
            updateStartGameButtonState();

            // Update chat messages if the lobby's chat changed
            renderChatMessages(updatedLobby.chatMessages);


            // Update game UI if game is active
            if (updatedLobby.gameStarted) {
                // Update current game state based on server data
                currentQuestionIndex = updatedLobby.currentQuestionIndex;
                currentPlayerIndex = updatedLobby.currentPlayerIndex;
                // The client's timer will reset when updateGameUI is called
                updateGameUI();
                startTimer(); // Restart timer for new turn/question
            }
        }
    });

    socket.on('lobbyDeleted', (deletedLobbyId) => {
        if (deletedLobbyId === currentLobbyId) {
            // If the lobby the user was in was deleted
            leaveLobbyStateCleanUp(); // Clean up client state, this will hide the chat
            showCustomModal("Lobby Ended", "The lobby has been disbanded. Returning to mode selection.");
        } else if (lobbyListContainer.style.display === 'flex') {
            renderLobbies(); // Refresh lobby list if a lobby was deleted
        }
    });

    socket.on('gameStarted', (startedLobby) => {
        if (startedLobby.lobbyId === currentLobbyId) {
            // Update local game state from the server's lobby object
            players = startedLobby.players;
            currentQuestionIndex = startedLobby.currentQuestionIndex;
            currentPlayerIndex = startedLobby.currentPlayerIndex;
            activeLobbies[currentLobbyId] = startedLobby; // Cache the lobby with its settings and questions

            startGameUI(startedLobby.type); // Transition to game UI, this will show the chat
            socket.emit('userEnteredGame', currentUser.id); // Inform server user is in game context
        }
    });

    socket.on('gameEnded', async (endedLobby) => {
        if (endedLobby.lobbyId === currentLobbyId) {
            if (timer) clearInterval(timer);
            socket.emit('userLeftGame'); // Inform server user left game context
            await showCustomModal("Game Over!", "The game has ended. Check the leaderboard for results!");
            // replayButton.style.display = 'block'; // Replay button is not defined in this scope
            // Hide all specific question boxes
            questionBox4v4.style.display = 'none';
            questionBox1v1Player1.style.display = 'none';
            questionBox1v1Player2.style.display = 'none';
            playerCardsContainer4v4.innerHTML = '';
            playerCardsContainer1v1.innerHTML = '';

            // Update current user's stats from the latest lobby data
            const updatedCurrentUser = endedLobby.players.find(p => p.id === currentUser.id);
            if (updatedCurrentUser) {
                // Fetch the latest user data from the backend to ensure all stats are up-to-date
                try {
                    const response = await fetch(`${BACKEND_URL}/api/auth/user`, {
                        method: 'GET',
                        headers: { 'x-auth-token': userToken }
                    });
                    const data = await response.json();
                    if (response.ok) {
                        currentUser = data; // Get fresh user data from backend
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                        welcomeMessage.textContent = `Logged in as: ${currentUser.username} (ID: ${currentUser.id}) ELO: ${currentUser.elo} Tokens: ${currentUser.tokens}`;
                        updateProfilePage(); // Update profile page
                    } else {
                        console.error("Failed to fetch updated user data after game end:", data.msg);
                    }
                } catch (error) {
                    console.error("Network error fetching updated user data after game end:", error);
                }
            }
            updateGlobalLeaderboard(); // Ensure global leaderboard is updated
            showSection(gameModeSelection); // Go back to game mode selection, this will hide the chat
        }
    });

    socket.on('chatMessage', (message) => {
        // Determine which chat box to render to based on currentLobbyType
        renderChatMessages(message);
    });

    // Inactivity penalty events
    socket.on('inactivityWarning', async ({ warningCount, maxWarnings }) => {
        // Only warn if in a match or solo challenge
        if (currentLobbyId || soloChallengeUI.style.display === 'flex') {
            await showCustomModal("Warning!", `You were inactive! You have ${warningCount} warning(s). ${maxWarnings} warnings will result in a penalty.`);
        }
    });

    socket.on('penaltyApplied', async ({ duration }) => {
        const durationSeconds = Math.ceil(duration / 1000);
        // Only show kick message if in a match
        if (currentLobbyId || soloChallengeUI.style.display === 'flex') {
            await showCustomModal("Penalty!", `You have been kicked from the match due to inactivity! You are penalized for ${durationSeconds} seconds.`);
            leaveGame(true); // Force leave game due to penalty
        } else {
            await showCustomModal("Penalty!", `You are penalized for ${durationSeconds} seconds due to inactivity.`);
        }
        // Update local currentUser penalty info
        // Fetch fresh user data to ensure penaltyEndTime is accurate
        try {
            const response = await fetch(`${BACKEND_URL}/api/auth/user`, {
                method: 'GET',
                headers: { 'x-auth-token': userToken }
            });
            const data = await response.json();
            if (response.ok) {
                currentUser = data;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
                checkAndApplyPenalty(); // Re-apply UI disables
            } else {
                console.error("Failed to fetch updated user data after penalty:", data.msg);
            }
        } catch (error) {
            console.error("Network error fetching updated user data after penalty:", error);
        }
    });

    socket.on('kickedFromGame', async ({ reason }) => {
        if (reason === 'inactivity') {
            // The penaltyApplied event already shows the main message, this is a secondary confirmation
            // No need to show another modal here, leaveGame(true) handles it.
        }
    });

    // Emit activity to server on user interaction
    document.addEventListener('mousemove', () => { if (currentUser) socket.emit('activity', currentUser.id); });
    document.addEventListener('keydown', () => { if (currentUser) socket.emit('activity', currentUser.id); });
    document.addEventListener('click', () => { if (currentUser) socket.emit('activity', currentUser.id); });

    // Modify the visibilitychange listener to only apply penalty if in a game
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            // Page is hidden
            isPageActive = false;
            // Only start inactivity timer if the user is currently in a game (multiplayer or solo)
            if (currentLobbyId || soloChallengeUI.style.display === 'flex') {
                socket.emit('activity', currentUser.id); // Send immediate activity to server
                // Server-side timer will handle the penalty logic
            }
        } else {
            // Page is visible
            isPageActive = true;
            if (currentUser) {
                socket.emit('activity', currentUser.id); // Inform server of activity
            }
        }
    });

    // Custom Game Creation Flow (Example - you might have a dedicated modal for this)
    function showCustomGameCreation() {
        currentLobbyType = 'custom-qna'; // Default to custom Q&A for creation
        openCreateLobbyModal();
    }

    // Floating Chat Box Logic
    const floatingChat = document.getElementById('floatingChat');
    const floatingChatHeader = document.getElementById('floatingChatHeader');
    const chatContent = document.getElementById('chatContent');
    const chatInput4v4 = document.getElementById('chatInput4v4'); // Re-using for general chat input
    const sendChatBtn4v4 = document.getElementById('sendChatBtn4v4'); // Re-using for general send chat button
    const toggleStickerPanelBtn = document.getElementById('toggleStickerPanelBtn');
    const stickerPanel = document.getElementById('stickerPanel');

    let isDraggingChat = false, offsetXChat = 0, offsetYChat = 0;

    floatingChatHeader.addEventListener('mousedown', e => {
        isDraggingChat = true;
        offsetXChat = e.clientX - floatingChat.offsetLeft;
        offsetYChat = e.clientY - floatingChat.offsetTop;
        floatingChat.style.cursor = 'grabbing';
    });

    document.addEventListener('mousemove', e => {
        if (!isDraggingChat) return;
        floatingChat.style.left = (e.clientX - offsetXChat) + 'px';
        floatingChat.style.top = (e.clientY - offsetYChat) + 'px';
        floatingChat.style.right = 'auto'; // Disable right/bottom constraints during drag
        floatingChat.style.bottom = 'auto';
    });

    document.addEventListener('mouseup', () => {
        isDraggingChat = false;
        floatingChat.style.cursor = 'grab';
    });

    sendChatBtn4v4.addEventListener('click', () => sendMessage());
    chatInput4v4.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    async function sendMessage() {
        if (!currentUser || !currentLobbyId) {
            await showCustomModal("Error", "You must be in a lobby and logged in to chat.");
            return;
        }

        const messageText = chatInput4v4.value.trim();
        if (messageText === '') return;

        try {
            const response = await fetch(`${BACKEND_URL}/api/lobbies/${currentLobbyId}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-auth-token': userToken
                },
                body: JSON.stringify({ message: messageText })
            });

            if (!response.ok) {
                await showCustomModal("Chat Error", "Failed to send message.");
            }
            chatInput4v4.value = ''; // Clear input field
            // Message will be rendered via Socket.IO 'chatMessage' event
        } catch (error) {
            console.error("Error sending chat message:", error);
            await showCustomModal("Chat Error", "Network error or server unavailable.");
        }
    }

    function renderChatMessages(messages) {
        chatContent.innerHTML = '';
        // Ensure messages is an array, even if a single message object is passed
        const messagesArray = Array.isArray(messages) ? messages : [messages];

        messagesArray.forEach(msg => {
            const div = document.createElement('div');
            div.className = `chat-message ${msg.senderId === currentUser.id ? 'self' : ''}`;
            if (msg.message.startsWith('http://') || msg.message.startsWith('https://')) {
                // Assume it's a sticker URL
                div.innerHTML = `<span class="sender-name">${msg.senderName}:</span><img src="${msg.message}" class="sticker">`;
            } else {
                div.innerHTML = `<span class="sender-name">${msg.senderName}:</span> ${msg.message}`;
            }
            chatContent.appendChild(div);
        });
        chatContent.scrollTop = chatContent.scrollHeight;
    }

    // Sticker System
    const stickerUrls = [
        "https://your-username.github.io/code-rivals-frontend/Stickers/photo1.jpeg", // Replace with your actual GitHub Pages sticker URLs
        "https://your-username.github.io/code-rivals-frontend/Stickers/photo2.jpeg",
        "https://your-username.github.io/code-rivals-frontend/Stickers/emote_happy.png",
        "https://your-username.github.io/code-rivals-frontend/Stickers/emote_sad.png",
        "https://your-username.github.io/code-rivals-frontend/Stickers/emote_thinking.png"
        // Add more sticker URLs here
    ];

    function loadStickersIntoPanel() {
        stickerPanel.innerHTML = '';
        stickerUrls.forEach(url => {
            const img = document.createElement('img');
            img.src = url;
            img.alt = "Sticker";
            img.title = "Click to send sticker";
            img.onclick = () => {
                // Send sticker URL as a chat message
                if (currentUser && currentLobbyId) {
                    chatInput4v4.value = url; // Put URL into chat input
                    sendMessage(); // Send it as a message
                } else {
                    showCustomModal("Error", "You must be in a lobby to send stickers.");
                }
            };
            stickerPanel.appendChild(img);
        });
    }

    toggleStickerPanelBtn.addEventListener('click', () => {
        stickerPanel.classList.toggle('hidden');
        if (!stickerPanel.classList.contains('hidden')) {
            loadStickersIntoPanel(); // Load stickers when panel is shown
        }
    });

    // Initial load of stickers (can be done once or on toggle)
    loadStickersIntoPanel();

    // Removed the MutationObserver for chat visibility as it's now handled by showSection
    // const mainLobbyDashboard = document.getElementById('gameModeSelection');
    // const obs = new MutationObserver(() => {
    //     if (mainLobbyDashboard.style.display !== 'none') {
    //         floatingChat.classList.remove('hidden');
    //     } else {
    //         if (singleLobbyView.classList.contains('hidden') && gameUI4v4.classList.contains('hidden') && gameUI1v1.classList.contains('hidden')) {
    //             floatingChat.classList.add('hidden');
    //         }
    //     }
    // });
    // obs.observe(mainLobbyDashboard, { attributes: true, attributeFilter: ['style'] });


</script>
</body>
</html>
